### Awakeable vs Promise

https://docs.restate.dev/develop/ts/external-events

In Restate, both `Awakeable` and `Promise` allow a service handler to pause its execution and wait for an external signal or event. The main difference is their use case: an `Awakeable` is for receiving external signals from systems outside of Restate, while a `Promise` is for coordinating signals between different handlers within a Restate workflow. 

**Awakeable**

An `Awakeable` is a pattern used in standard Restate services (Virtual Objects or Basic Services) to wait for an event from an external, non-Restate system. 

- **Identifier-based**: When you create an `Awakeable`, Restate generates a unique, opaque ID and a corresponding promise.
- **External completion**: Your service sends this unique ID to the external system. The external system, upon completing its task, must then call the Restate ingress API using the ID to resolve the `Awakeable`.
- **Use case**: Best for scenarios where you need to wait for a third-party service, such as a payment gateway, to complete a transaction and send a callback to your Restate service. 

**Promise**

A durable `Promise` is specifically designed for use inside Restate **workflows** to facilitate communication between different handlers within the same workflow. 

- **Logical name**: Instead of a unique, opaque ID, a `Promise` is identified by a user-defined logical name (a string).
- **Internal completion**: The `Promise` is resolved by another handler within the same workflow using a signal.
- **Use case**: Ideal for complex, multi-step workflows where you need to coordinate between different parts of the process. For example, waiting for human input ("manager-approval") or for another workflow step to complete ("payment-completed").
- **Workflow-scoped**: The `Promise` is scoped to the lifetime of the workflow execution. 

Comparison table

|Feature|Awakeable|Promise|
|---|---|---|
|**Use case**|Awaiting events from **external, non-Restate systems**.|Awaiting events from other handlers **within the same Restate workflow**.|
|**Identifier**|A unique, opaque string ID generated by Restate.|A user-defined, logical string name.|
|**Completion**|Resolved by an **external system** making a call to the Restate ingress API using the generated ID.|Resolved by another **signal handler** within the same Restate workflow.|
|**Context**|Used in Basic Services and Virtual Objects.|Used exclusively in Workflows.|
|**ID Management**|The unique ID must be managed by the calling service, which passes it to the external system.|The logical name is managed by the workflow and does not require passing a unique ID to external parties.|


In the Restate Go SDK, both `Awakeable` and `Promise` facilitate asynchronous operations and waiting for external events, but they differ in their primary use cases and how they are resolved:

Awakeable:

- **Purpose:** 
    
    `Awakeable` is designed for coordinating with external systems or processes outside of Restate. It represents a future result that will be provided by an external source.
    
- **Mechanism:** 
    
    When you create an `Awakeable`, Restate generates a unique ID and a response URL. You then pass this ID and URL to the external system, which uses them to resolve (or reject) the `Awakeable` with a result.
    
- **Use Cases:**
    
    - Waiting for a payment gateway to process a transaction.
    - Integrating with a third-party API that provides a callback.
    - Human interaction, such as waiting for a user to confirm an action in an external UI.
    

Promise:

- **Purpose:** 
    
    `Promise` (or Durable Promise) is used for workflow signaling within Restate. It represents a future result that will be resolved or rejected by another part of the same Restate workflow or another Restate service.
    
- **Mechanism:** 
    
    `Promise` is created and resolved/rejected within the Restate environment. It's typically used to communicate between different parts of a long-running workflow or between different Restate services.
    
- **Use Cases:**
    
    - Signaling completion of a sub-task within a workflow.
    - Waiting for a specific event to occur in another Restate service.
    - Implementing durable timers or delays within a workflow.
    

Key Differences and When to Use:

|Feature|Awakeable|Promise|
|---|---|---|
|Resolution|External system using a unique ID/URL|Another part of the Restate workflow/service|
|Scope|Interacting with systems outside Restate|Signaling and coordination within Restate|
|Use Case|External callbacks, third-party integrations|Workflow signaling, internal event handling|

In summary:

- Use `Awakeable` when your Restate service needs to wait for a result from a system or process that is not part of your Restate application.
- Use `Promise` when you need to coordinate or wait for an event or result that will be produced by another component within your Restate application or workflow.

The Restate platform offers three distinct service types—Basic Service, Virtual Object, and Workflow—each optimized for different concerns regarding state, concurrency, and longevity.

Here is a detailed breakdown of when to use each service type, including specific use cases and the rationale for that choice, drawing comprehensively from the sources.

***

## 1. Basic Service (Stateless Service)

The Basic Service is the most straightforward service type, acting as a collection of **independent stateless handlers**.

| Characteristic | Description |
| :--- | :--- |
| **State & Identity** | **None**. They do not share state between requests. |
| **Concurrency** | **Unlimited parallel execution**. |
| **Context Type** | Uses the basic `Context` type. |

### Key Use Cases and Rationale

| Use Case | Why Use Basic Service |
| :--- | :--- |
| **API Calls & Background Jobs** | **Rationale:** They are ideal for business logic, data processing, and API integrations that do not require state persistence or concurrency management within Restate. |
| **Task Parallelization / Fan-Out Fan-In** | **Rationale:** Used to schedule multiple tasks asynchronously and gather the results, ensuring **high concurrency and horizontal scaling**. The ability to scale horizontally with high concurrency is a key benefit. |
| **Sagas / Distributed Transactions** | **Rationale:** Basic Services can be used as the orchestration point for Sagas, which implement resilient compensation (rollback) logic for multi-service transactions in case of terminal failures. |
| **Durable Webhooks / ETL** | **Rationale:** They function as durable webhook processors, persisting incoming events and ensuring they are **processed exactly once** using idempotency keys. |
| **Microservice Orchestration** | **Rationale:** Serves as the main orchestrator for services where the orchestration steps themselves are atomic and don't need persistent state *between* different key invocations. |

***

## 2. Virtual Object (Durable Object)

A Virtual Object models a **stateful entity** identified by a unique key. It provides actor-like semantics with built-in consistency guarantees.

| Characteristic | Description |
| :--- | :--- |
| **State & Identity** | **Isolated persistent K/V state per object key**. State is retained indefinitely (until explicitly cleared). |
| **Concurrency** | **Single writer per key** (exclusive handlers use `ObjectContext`) plus **concurrent readers** (shared handlers use `ObjectSharedContext`). Calls execute in order of arrival, serially. |
| **Context Type** | `ObjectContext` (exclusive, read/write state) and `ObjectSharedContext` (shared, read-only state). |

### Key Use Cases and Rationale

| Use Case | Why Use Virtual Object |
| :--- | :--- |
| **Stateful Entities (Actors/Digital Twins)** | **Rationale:** Ideal for modeling real-world entities like **user accounts, shopping carts, or chat sessions**. The built-in K/V state is retained permanently and automatically journaled alongside execution steps. |
| **Consistent State Machines** | **Rationale:** Guarantees **single-writer consistency per object key**. This prevents race conditions, concurrent/lost writes, and ensures that state updates are always consistent with the durable execution logic. |
| **Stateful Event Processing** | **Rationale:** When invoked via Kafka, the Kafka key maps directly to the Virtual Object key, enabling **queue-per-key ordering guarantees**. This is necessary for event-driven state machines and processing pipelines where aggregates or joins are needed. |
| **AI Agents and Session Management** | **Rationale:** Used to manage **persistent memory and context** (conversation history) across multi-turn interactions for AI agents. The exclusive handler ensures only one message is processed at a time per session ID, ensuring consistency. |
| **Distributed Coordination** | **Rationale:** Can model distributed locks, semaphores, or leases, as they offer state that is guaranteed to be consistent and is scoped per entity. |

***

## 3. Workflow

A Workflow is a long-lived process designed for **orchestrating multi-step operations** with a guaranteed exactly-once execution per ID.

| Characteristic | Description |
| :--- | :--- |
| **State & Identity** | **Isolated persistent state per workflow instance** (workflow ID). State and metadata are retained only for the configured retention period (default 24 hours). |
| **Concurrency** | A **single `run` handler** executes the main logic exactly once per ID. Additional **shared handlers** (for signals/queries) run concurrently with `run`. |
| **Context Type** | `WorkflowContext` (exclusive, for `run` handler) and `WorkflowSharedContext` (shared, for signals/queries). |

### Key Use Cases and Rationale

| Use Case | Why Use Workflow |
| :--- | :--- |
| **Long-Running Orchestration** | **Rationale:** Designed to coordinate complex, multi-step processes like user onboarding or signup flows. The **`run` handler executes exactly once** for a given ID, making it ideal for processes that should never be duplicated. |
| **Human-in-the-Loop Processes** | **Rationale:** Necessary for processes requiring interaction (approvals, reviews, manual steps). Workflows use **Durable Promises** (for internal signaling) or **Awakeables** (for external systems) to pause execution and wait for events. |
| **Time-Based Coordination** | **Rationale:** Critical for implementing **long-running durable timers, sleeps, or timeouts** that survive crashes and service restarts. When running on FaaS, the workflow handler suspends while waiting for timers or events, saving costs. |
| **Event-Driven Workflows** | **Rationale:** Allows for complex control flow (loops, conditions) around durable steps. Unlike Basic Services, workflows manage their own dedicated lifecycle and state retention. |
| **Queryable Process Status** | **Rationale:** Handlers using `WorkflowSharedContext` can expose state and completion status concurrently while the main `run` handler is executing or suspended, allowing external systems to query the current progress. |


## 4. Code

The Restate platform classifies services into three types: **Basic Service**, **Virtual Object**, and **Workflow**. The choice depends on requirements for state management, concurrency control, and process longevity.

Below, I itemize the use cases, rationale, and corresponding GoLang code (where available in the sources) for each service type.

***

## 1. Basic Service (Stateless Service)

The Basic Service is for executing **stateless business logic** and orchestrating tasks with high concurrency.

| Use Case | Rationale | GoLang Code Example |
| :--- | :--- | :--- |
| **Microservice Orchestration** | Used for orchestrating complex business logic by calling multiple services sequentially. Durable Execution ensures the request runs to completion, retrying transient errors at each step. | **Subscription Service `Add` Handler (Sequential durable steps):** [Go] ```func (SubscriptionService) Add(ctx restate.Context, req SubscriptionRequest) error { // ... paymentId := restate.UUID(ctx).String() payRef, err := restate.Run(ctx, func(ctx restate.RunContext) (string, error) { return CreateRecurringPayment(req.CreditCard, paymentId) }, restate.WithName("pay")) if err != nil { return err } for _, subscription := range req.Subscriptions { _, err := restate.Run(ctx, func(ctx restate.RunContext) (string, error) { return CreateSubscription(req.UserId, subscription, payRef) }, restate.WithName(fmt.Sprintf("add-%s", subscription))) if err != nil { return err } } return nil }``` |
| **Task Parallelization / Fan-Out Fan-In** | Used to execute multiple durable operations (`ctx.run` or RPCs) simultaneously to improve performance. Restate logs the order of completion for deterministic replay. | **Fan-Out Worker `Run` Handler (Parallel tasks using `restate.Wait`):** [Go] `// Fan out the subtasks - run them in parallel subtaskFutures := make([]restate.Future, 0, len(subtasks)) for _, subtask := range subtasks { subtaskFutures = append(subtaskFutures, restate.Service[SubTaskResult](ctx, "FanOutWorker", "RunSubtask").RequestFuture(subtask)) } // Fan in - Aggregate the results subResults := make([]SubTaskResult, 0, len(subtasks)) for fut, err := range restate.Wait(ctx, subtaskFutures...) { // ... error handling and result aggregation ... }` |
| **Sagas / Distributed Compensation** | Used to implement resilient compensation (rollback) logic for multi-service transactions when a non-transient error (`TerminalError`) occurs. | **Booking Workflow `Run` Handler (Compensation using `defer`):** [Go] `func (BookingWorkflow) Run(ctx restate.Context, req BookingRequest) (err error) { var compensations []func() (restate.Void, error) defer func() { if err != nil { for _, compensation := range slices.Backward(compensations) { if _, compErr := compensation(); compErr != nil { err = compErr } } } }() compensations = append(compensations, func() (restate.Void, error) { // Compensation logic (CancelFlight) ... }) if _, err = restate.Run(ctx, // ... BookFlight logic ... ); err != nil { return err } // ... append more compensations and run subsequent steps ... return nil }` |
| **Durable Webhooks / ETL** | Acts as a durable processor for incoming events (like webhooks or Kafka events), ensuring they are processed exactly once. | *No specific Go code example is provided for a generic webhook handler, but the implementation relies on the Basic Service structure combined with Durable Execution.* |

***

## 2. Virtual Object (Durable Object)

A Virtual Object is used to model a **stateful entity** identified by a key, offering **single-writer consistency** and permanent state storage.

| Use Case | Rationale | GoLang Code Example |
| :--- | :--- | :--- |
| **Stateful Entities (User Accounts, Shopping Carts)** | Ideal for modeling entities with isolated, persistent K/V state that must survive crashes and restarts. Uses exclusive handlers (`ObjectContext`) for read/write access and serial execution to ensure data consistency per key. | **User Account `UpdateBalance` Handler (Exclusive, Read/Write State):** [Go] `func (UserAccount) UpdateBalance(ctx restate.ObjectContext, amount float64) (float64, error) { balance, err := restate.Get[float64](ctx, "balance") // ... error handling ... newBalance := balance + amount if newBalance < 0.0 { return 0.0, restate.TerminalError(errors.New("insufficient funds")) } restate.Set(ctx, "balance", newBalance) return newBalance, nil }` |
| **AI Agents and Session Management** | Used to implement stateful AI agents by persisting memory, conversation history, and context using the K/V store. The single-writer guarantee maintains chat integrity across turns. | *The provided sources do not include a Go example for the AI Session Provider, but the underlying state logic is the same as the `UserAccount` example above, using `restate.ObjectContext` to manage state.* |
| **Rate Limiting** | Provides isolated rate limit counters per key (e.g., user ID or endpoint), combining state (`tokens`) with durable timers (`restate.Sleep`) to implement algorithms like the Token Bucket, ensuring resilience and correctness. | **Limiter Service `ReserveN` Handler (State management with durable steps):** [Go] `func (Limiter) ReserveN(ctx restate.ObjectContext, req types.ReserveRequest) (types.Reservation, error) { // ... get state ... // ... calculations wrapped in restate.Run to get deterministic time // ... if reservation is successful and update is needed restate.Set(ctx, "state", result.LimiterState) return result.Reservation, nil }` |

***

## 3. Workflow

A Workflow is a long-lived process optimized for **orchestrating multi-step operations** that require waiting for external interaction or durable timers, with an exactly-once guarantee for the main execution thread (`Run` handler).

| Use Case | Rationale | GoLang Code Example |
| :--- | :--- | :--- |
| **Human-in-the-Loop Workflows & Approvals** | Workflows can pause execution indefinitely using **Durable Promises** (for internal signaling) or **Awakeables** (for external systems), and suspend the handler to save FaaS costs. | **Signup Workflow `Run` Handler (Waiting for Promise resolution):** [Go] `func (SignupWithSignalsWorkflow) Run(ctx restate.WorkflowContext, user User) (bool, error) { // ... send verification email step ... // Wait for user to click verification link clickedSecret, err := restate.Promise[string](ctx, "email-verified").Result() if err != nil { return false, err } return clickedSecret == secret, nil } func (SignupWithSignalsWorkflow) VerifyEmail(ctx restate.WorkflowSharedContext, req VerifyEmailRequest) error { // Resolve the promise to continue the main workflow return restate.Promise[string](ctx, "email-verified").Resolve(req.Secret) }` |
| **Durable Timers and Scheduling (Cron Jobs)** | Used for long-running pauses, scheduling repeating tasks, and implementing complex logic (e.g., loops with delays). Timers survive crashes and suspend execution, resuming at the exact remaining time. | **Signup Workflow `Run` Handler (Racing Promise against Timers):** [Go] `clickedPromise := restate.Promise[string](ctx, "email-verified") verificationTimeoutFuture := restate.After(ctx, 24*time.Hour) for { reminderTimerFuture := restate.After(ctx, 15*time.Second) resFut, err := restate.WaitFirst(ctx, clickedPromise, reminderTimerFuture, verificationTimeoutFuture) // ... switch on resFut to handle promise result, reminder email, or timeout ... }` |
| **Complex Multi-Step Flows** | The combination of a single exactly-once `Run` handler, durable state persistence, and native looping/conditional constructs (`if/else`, `while`) enables complex orchestration flows that are highly observable and resilient. | **Workflow Structure:** [Go] `type MyWorkflow struct{} func (MyWorkflow) Run(ctx restate.WorkflowContext, req string) (string, error) { // implement the workflow logic here return "success", nil } func (MyWorkflow) InteractWithWorkflow(ctx restate.WorkflowSharedContext) error { // implement interaction logic here return nil }` |

### Summary of Service Usage

To summarize, you should **Start with Basic Services** for general business logic and orchestration, **Use Virtual Objects** to model data entities that need consistent state per key, and **Use Workflows** for processes that require pauses, waiting for events, or have a defined, long lifecycle.


## 5. CODE REDUX

This list comprehensively details the required and recommended actions ("Do's") and the forbidden or cautioned actions ("Don'ts") within the Restate development and operational environments, categorized for clarity.

***

## Do's (Recommendations and Requirements)

### I. Durable Execution & Determinism

1.  **Wrap Non-Deterministic Operations:**
    Any non-deterministic operation, such as HTTP calls, database responses, network calls, or UUID generation, must be wrapped using the Restate context durable step feature (`ctx.run` or equivalent) to ensure deterministic replay and persistence in the execution log.

    ```go
    // Go Example: Wrapping a database request in restate.Run
    result, err := restate.Run(ctx, func(ctx restate.RunContext) (string, error) {
        return doDbRequest()
    })
    if err != nil {
        return err
    } //
    
    // TypeScript Example: Wrapping an external API call
    const apiResult = await ctx.run("fetch-data", async () => {
        const response = await fetch("https://api.example.com/data");
        return response.json();
    }); //
    ```

2.  **Use Context Logger:**
    To avoid duplicate log statements during replays, use the Restate context logger (`ctx.Log()` in Go, `ctx.console` in TypeScript) instead of the default logger.

    ```typescript
    ctx.console.info("This will not be printed again during replays"); //
    ```

3.  **Generate Deterministic IDs and Time:**
    Generate stable UUIDs for idempotency keys and similar needs using the SDK's deterministic helpers, as they are seeded by the invocation ID and return the same result on retries. Similarly, use `ctx.date.now()` or equivalent methods for deterministic time.

    ```go
    uuid := restate.UUID(ctx) //
    ```

4.  **Handle Tool Execution Resiliency (AI Agents):**
    For AI agents, use Restate Context actions (e.g., `ctx.run`) to make tool executions resilient. Persist LLM responses using the `durableCalls` middleware.

    ```typescript
    // Vercel AI SDK example using ctx.run for resilience
    execute: async ({ city }) => {
        return await ctx.run("get weather", () => fetchWeather(city));
    }, //
    ```

### II. Concurrency and Flow Control

1.  **Parallelize Tasks Safely (Fan-Out/Fan-In):**
    Start multiple durable operations concurrently by calling them without immediate awaiting, and then use the SDK's durable combinators (`restate.Wait`, `restate.WaitFirst`, `restate.gather`, `RestatePromise.all`, etc.) to collect results.

    ```go
    // Go Example: Waiting for all tasks to complete
    callFuture1 := restate.Service[string](ctx, "MyService", "MyHandler").RequestFuture("hi")
    callFuture2 := restate.Service[string](ctx, "MyService", "MyHandler").RequestFuture("hi again") //
    
    for fut, err := range restate.Wait(ctx, callFuture1, callFuture2) {
        // ... process results ...
    } //
    ```

2.  **Implement Timeouts and Racing:**
    Use combinators like `restate.WaitFirst` (Go) or `restate.select()` (Python) to race an asynchronous operation against a durable timer (`restate.After` / `ctx.sleep`), handling the resulting winner deterministically.

    ```go
    // Go Example: Racing a sleep future against a service call future
    sleepFuture := restate.After(ctx, 30*time.Second)
    callFuture := restate.Service[string](ctx, "MyService", "MyHandler").RequestFuture("hi")
    fut, err := restate.WaitFirst(ctx, sleepFuture, callFuture) //
    // ... switch on fut to determine winner ...
    ```

3.  **Use Durable Sleep:**
    Use `ctx.sleep` (`restate.After` in Go) to pause a handler for a set duration, leveraging Restate's suspension feature to save FaaS costs.

    ```go
    sleepFuture := restate.After(ctx, 30*time.Second) //
    ```

### III. State, Communication, and Error Handling

1.  **Manage State in Virtual Objects/Workflows:**
    Use `restate.Set` and `restate.Get` (or equivalent SDK functions) to manage persistent key-value state within Virtual Objects and Workflows. This state is durable and consistent with execution.

    ```go
    // Go Example: Setting and getting state
    restate.Set(ctx, "my-key", "my-new-value") //
    myNumber, err := restate.Get[int](ctx, "my-number-key") //
    restate.ClearAll(ctx) // Clear all state
    ```

2.  **Use Exclusive vs. Shared Handlers:**
    In Virtual Objects, use handlers with `ObjectContext` (exclusive/read-write) for state modification and handlers with `ObjectSharedContext` (shared/read-only) for concurrent reading of state.

3.  **Use Idempotency Keys:**
    Provide an idempotency key when invoking a service call or sending a message (especially via external clients or cross-handler calls) to prevent duplicate executions across different handler invocations.

    ```go
    // Go Example: Sending a message with an idempotency key
    restate.ServiceSend(ctx, "MyService", "MyHandler").
        Send("Hi", restate.WithIdempotencyKey("my-idempotency-key")) //
    ```

4.  **Use Awakeables vs. Durable Promises:**
    Use **Awakeables** when services or Virtual Objects need to coordinate with *external systems* (e.g., human approval, webhooks). Use **Durable Promises** for signaling *between handlers within the same Workflow*.

    ```go
    // Go Example: Resolving a Durable Promise from a Workflow handler
    err := restate.Promise[string](ctx, "review").Resolve(review) //
    ```

5.  **Throw Terminal Errors:**
    For non-transient failures (e.g., invalid input, business logic failures) where retrying won't help, throw a `TerminalError` (or `TerminalException`) to stop execution and propagate the error back to the caller.

    ```go
    return restate.TerminalError(fmt.Errorf("Something went wrong."), 500) //
    ```

6.  **Implement Sagas:**
    Implement compensating actions for each durable step in a list, and execute them in reverse order within a `catch` block that handles the propagated `TerminalError`. Compensations should be idempotent.

    ```typescript
    // TypeScript Example: Sagas compensation logic
    } catch (e) {
        if (e instanceof restate.TerminalError) {
            for (const compensation of compensations.reverse()) {
                await compensation();
            }
        }
        throw e;
    } //
    ```

### IV. Deployment and Operations

1.  **Use Immutable Deployment Versions:**
    Always deploy code changes using new, immutable deployment versions. Restate automatically routes new traffic to the latest version while allowing ongoing invocations to complete on the old version.

2.  **Handle HTTP/1.1 Deployment Registration:**
    If deploying services on platforms that only support HTTP/1.1 (like Uvicorn or certain serverless runtimes), register the service deployment using the `--use-http1.1` flag.

3.  **Ensure HTTPS and HTTP/2 for Public Endpoints:**
    If using publicly accessible service endpoints, **HTTPS must be used** between Restate and your services, and the load balancer should **support HTTP/2** for optimum performance.

4.  **Align RocksDB Memory:**
    In a Kubernetes environment, configure the RocksDB memory limit (`rocksdb-total-memory-size`) to align with pod memory requests and limits, typically setting it to 75% of the pod's memory requests.

5.  **Enable JSON Logging in Production:**
    When deploying in production, set the log level to `info` and enable the `json` format (`log-format = "json"`) for compatibility with log collectors.

### V. AI Agent Best Practices

1.  **Raise Restate Errors in Tools (OpenAI SDK):**
    When defining tools for the OpenAI Agent SDK, set the `failure_error_function` to `raise_restate_errors` to ensure that errors like suspensions or terminal errors are handled by Restate, rather than being consumed by the agent framework.

    ```python
    @function_tool(failure_error_function=raise_restate_errors)
    async def get_weather(
        wrapper: RunContextWrapper[restate.Context], req: WeatherRequest
    ) -> WeatherResponse:
    # ... durable tool execution ...
    ```

2.  **Add AGENTS.md Rules:**
    To improve the performance and behavior of AI coding agents (like Cursor or Claude Code) when generating Restate code, add the relevant SDK's `AGENTS.md` rules file to the agent's context (e.g., in the `.cursor/rules` or `.claude` folder).

***

## Don'ts (Actions to Avoid or Be Careful About)

### I. Determinism Violations

1.  **Avoid Native Concurrency for Durable Operations (Go):**
    Do not try to combine blocking Restate operations using **goroutines, channels, or select statements** outside of a `restate.Run` function, as this leads to non-determinism errors upon replay.

2.  **Avoid Context Operations inside `ctx.run`:**
    You cannot use the Restate context (`ctx.get`, `ctx.sleep`, or nested `ctx.run`) inside a `ctx.run` or `restate.Run` block.

3.  **Avoid Unversioned Code Changes:**
    Do not change the underlying service code (e.g., update the container image) without registering a new version of the service deployment, as this causes a **Journal Mismatch** (RT0016) or non-deterministic errors.

4.  **Do Not Use Deterministic IDs for Cryptography:**
    Do not use UUIDs generated by Restate's deterministic helpers (`restate.UUID(ctx)`, `ctx.random().nextUUID()`) in cryptographic contexts.

### II. Concurrency and Deadlock Risks

1.  **Avoid Blocking Exclusive Handlers:**
    Do not use `ctx.sleep` or wait for an `Awakeable` in an **exclusive handler** of a Virtual Object, because this will queue and block all other calls to that specific object key.

2.  **Avoid Object Call Deadlocks:**
    Avoid complex request-response calls between exclusive handlers of Virtual Objects that lead to **cross deadlocks** (A $\to$ B and B $\to$ A with the same key) or **cycle deadlocks** (A $\to$ B $\to$ C $\to$ A).

3.  **Avoid Mutually Calling Agents in the Same Object:**
    Do not place mutually calling agents within the same Virtual Object keyed instance, as this leads to deadlocks because the exclusive handler will block on the sub-agent call.

### III. Error Handling and Logging

1.  **Do Not Catch Generic Exceptions (Python):**
    In Python, **do not** use bare `except:` or `except Exception:` (`except:` catches internal SDK exceptions); only catch specific errors like `TerminalError`.

2.  **Avoid Redundant Idempotency Keys:**
    Do not provide an idempotency key for service calls made during the same handler execution, as Restate automatically handles deduplication in that specific context.

### IV. Deployment and Storage

1.  **Avoid In-Place Updates:**
    Avoid using **in-place updates** (`PUT /deployments/{deployment}`) except in rare cases for critical bug fixes, as this approach breaks determinism if not carefully handled and is discouraged compared to immutable versioning.

2.  **Avoid Changing Log Server Location:**
    It is **strongly recommended not to change the node's location string** after its initial registration if the `log-server` role is enabled, as this may result in data loss or inconsistency.

3.  **Do Not Assume Full Encryption:**
    It is not possible to encrypt all journal entries. Only specific entries are encrypted: handler I/O, `ctx.run` success results, RPC parameters/returns, state values, Awakeables, and Durable Promise results.

Based on the comprehensive review of the provided sources, here is an itemized list of do's and don'ts for developing, deploying, and operating services within the Restate environment.

***

### Do's (Recommendations and Requirements)

#### I. General Development & Handler Logic

1.  **Use Context for Operations:** Always invoke handlers via the Restate context (`ctx`) if you have access to it.
2.  **Ensure Durability:** Use the `Context` to interact with Restate, as the SDK stores these actions in the Restate journal to make them durable.
3.  **Wrap Non-Deterministic Operations:** Use `ctx.run` (or `restate.Run`/equivalent SDK function) to safely wrap any non-deterministic operation (like HTTP calls, database responses, network calls, API calls, or database interaction), ensuring Restate persists its result in the execution log and retries transient errors until they succeed.
4.  **Use Context Logger for Logging:** Use the **Restate context logger** (`ctx.Log()` in Go, `ctx.console` in TypeScript) to avoid duplicate log statements during handler replays.
5.  **Manage Handler Runtime:** Break long-running handlers (days or months) into smaller chunks and **chain them via delayed messages or service-to-service calls**.
6.  **Handle Long Operations:** Adjust the service's **abort timeout and inactivity timeout** settings to accommodate long-running operations, such as LLM calls that take up to 3 minutes.

#### II. Concurrency and Parallelism

1.  **Use Concurrent Tasks:** Use concurrent tasks when you need to call multiple external services simultaneously, race operations (for timeouts/first result), or perform batch operations.
2.  **Safely Wait on Futures (Go):** Use `restate.Wait` or `restate.WaitFirst` to safely wait on futures concurrently.
3.  **Safely Wait on Futures (Java/Kotlin):** Use `Select.select()` or `select { ... }` to wait for the first completion, and `DurableFuture.all` or `list.awaitAll()` to wait for all tasks to complete.
4.  **Safely Wait on Futures (Python):** Use `restate.select()` to race operations, `restate.gather()` to wait for all tasks, or `restate.wait_completed()` to handle completed results and potentially cancel pending ones.
5.  **Parallelize Agent Steps:** To parallelize AI agent tool steps, implement an orchestrator tool that uses durable execution combinators (like `restate.gather` or `RestatePromise.all`) to run multiple steps in parallel.

#### III. Service Types and Communication

1.  **Choose Appropriate Service Types:**
    *   Start with **Basic Services** for general business logic, data processing, API calls, sagas, background jobs, and ETL.
    *   Use **Virtual Objects** to model stateful entities (user accounts, agents, state machines).
    *   Use **Workflows** for multi-step processes that execute exactly-once and require external interaction or orchestration.
2.  **Handle Workflow Execution:** Ensure the workflow's `run` handler executes **exactly once per workflow ID**.
3.  **Use Idempotency Keys:** Use an **idempotency key** when invoking a handler (via request header, SDK client, or service message options) to prevent duplicate execution, especially if multiple callers might call the same service independently.
4.  **Attach to Invocations:** Use the `attach` mechanism (via SDK or HTTP) to retrieve the result of an ongoing invocation or workflow if an idempotency key was used.

#### IV. State Management and Data

1.  **Use State for Correctness:** Use Restate state (Virtual Objects/Workflows) for state requiring **tight integration with function logic, resilience, and correctness**, such as transactional state machines, session state, or AI agent context.
2.  **Use Database for Complex Access:** Use a separate database when you need complex access patterns, full SQL, text search, time-series analysis, or for core business data accessed by external services.
3.  **Manage State Access:** Use **exclusive handlers** (`ObjectContext`, `WorkflowContext`) for **read and write state access**.
4.  **Query State Safely:** Use **shared handlers** (`ObjectSharedContext`, `WorkflowSharedContext`) for **read-only state access**, as they run concurrently.
5.  **Clear State:** Clear long-lived Virtual Object state explicitly using `ctx.clear()` or `ctx.clear_all()`.
6.  **Handle Serialization:** Use **Pydantic models** (Python) or similar structures/custom serializers to define the structure of data for handler input/output, state, and serialization if default JSON is insufficient.
7.  **Choose State Loading Strategy:** Consider enabling **lazy state** loading for large state objects that are rarely accessed. Use the default **eager state** for small, frequently accessed state, especially when running on platforms like AWS Lambda where replay costs are a concern.
8.  **Database Semantic Locks (Advanced):** To ensure exactly-once semantics for database updates, implement the semantic lock pattern by separating reads (via `ctx.run`) and conditional updates based on versions.

#### V. Error Handling, Timers, and External Events

1.  **Signal Permanent Failure:** Use `TerminalError` (or equivalent exception) to signal permanent failures (e.g., invalid input, business logic failures) to **stop infinite retries**.
2.  **Implement Sagas:** Implement Sagas by building a list of compensating actions for business logic steps and executing them in **reverse order** within a `catch` block that handles `TerminalError`.
3.  **Ensure Compensations are Idempotent:** Make sure that compensating actions are idempotent.
4.  **Order Compensation Registration:** When using one-shot APIs (e.g., payment), register the compensation (e.g., refund) **before** executing the main action (e.g., charge).
5.  **Use Awakeables for External Coordination:** Use **Awakeables** for Services and Virtual Objects when coordinating with external systems (human-in-the-loop, webhooks, async APIs).
6.  **Use Durable Promises for Internal Signaling:** Use **Durable Promises** exclusively within Workflows for signaling between different workflow handlers.
7.  **Handle Await Failures:** **Always handle rejections** from Durable Promises or Awakeables to gracefully manage failures.
8.  **Set Timeouts for External Waits:** Include timeouts for long-running external processes and context actions (calls, awakeables).
9.  **Use Suspensions on FaaS:** Leverage Restate's suspension feature (when waiting on durable operations like sleep or awakeables) to **save costs** on Function-as-a-Service platforms.

#### VI. Deterministic Randomness and Time

1.  **Generate Deterministic UUIDs:** Use the SDK's deterministic helpers (`restate.UUID(ctx)`, `ctx.random().nextUUID()`, `ctx.random().uuid4()`) to generate stable UUIDs for purposes like idempotency keys.
2.  **Generate Deterministic Time:** Use `ctx.date.now()` (TS) or similar methods to get a deterministic time consistent across retries.

#### VII. Deployment, Infrastructure, and Security

1.  **Use Immutable Versions:** Restate requires the use of **immutable versions** for deployments to ensure deterministic durable execution upon replay.
2.  **Keep Old Deployments:** If using long sleeps or long-running invocations, you need to **keep the old deployment version** around until the invocation completes.
3.  **Register HTTP/1.1 Deployments:** If deploying services using a server that only supports HTTP/1.1 (e.g., Uvicorn, Vercel/Next.js), specify the `--use-http1.1` flag during registration.
4.  **Use HTTPS for Public Endpoints:** If your services are deployed as public endpoints (e.g., serverless functions), **HTTPS must be used** between Restate and your services.
5.  **Use HTTP/2 Load Balancer:** For optimum performance, the load balancer in front of your services **must support HTTP/2**.
6.  **Secure Public Endpoints:** **Secure access** to publicly routable services so that only the designated Restate environment can call them.
7.  **Validate Request Identity:** Use Restate's native request identity feature/SDK methods to cryptographically verify that incoming requests originate from the correct Restate instance.
8.  **Configure Kubernetes Security:** In a production Kubernetes environment, configure appropriate **network policies for security**.
9.  **RocksDB Memory Sizing:** When configuring Restate Server settings for RocksDB memory, set the limit (e.g., `rocksdb-total-memory-size`) to align with pod memory limits, typically **75% of pod requests**.
10. **Use Snapshots in Clusters:** **Snapshots are essential** and required when operating a multi-node cluster, adding/removing nodes, or enabling log trimming.
11. **Metadata Storage:** **S3 is the only supported object store for metadata storage**.
12. **Upgrades:** Perform **data backups** and **verify the upgrade path in an isolated test environment** before performing software upgrades.

#### VIII. AI Agents and Assisted Development

1.  **Use Durable Execution for Agents:** Use Durable Execution to make AI agents resilient to LLM calls and tool execution failures.
2.  **Persist LLM Responses:** Wrap the model with the `durableCalls` middleware to ensure every LLM response is saved and can be replayed.
3.  **Set Tool Error Handling (OpenAI SDK):** When using the OpenAI Agent SDK, always set the tool's `failure_error_function` to **raise Restate errors** (like suspensions or terminal errors) to ensure the agent doesn't consume them internally.
4.  **Use AGENTS.md:** For AI coding agents (Cursor, Claude Code), **add the AGENTS.md rules** to the agent's context (in the `.cursor/rules` or `.claude` folders) to improve performance.

***

### Don'ts (Actions to Avoid)

#### I. Core Durability and Determinism Violations

1.  **Avoid Using Bare Exceptions (Python):** **DO NOT use bare `except:` or `except Exception:`** in Restate handlers, as this catches internal SDK exceptions that must not be handled, leading to unexpected behavior.
2.  **Avoid Combining Blocking Operations with Native Concurrency (Go):** **Do not use Go routines, channels, or select statements** to combine blocking Restate operations outside of a `restate.Run` function, as this causes **non-determinism errors** upon replay.
3.  **Avoid Context Misuse in Run Blocks:** Inside a `ctx.run` or `restate.Run` block, **you cannot use the Restate context** (e.g., `ctx.get`, `ctx.sleep`, or nested `ctx.run`).
4.  **Avoid Non-Deterministic Execution Flow:** **Do not branch the execution flow based on non-deterministic information** (e.g., elapsed time, unrecorded HTTP results, random values, current date-time).
5.  **Avoid Non-Deterministic Iteration:** **Do not execute Context operations** while iterating over data structures with **non-deterministic iteration order** (like sets/maps/dictionaries).
6.  **Avoid Non-Cryptographic Deterministic IDs:** **Do not use Restate-generated UUIDs** (e.g., `restate.UUID(ctx)`) in cryptographic contexts.

#### II. Service Communication and State Risks

1.  **Avoid Deadlocks in Virtual Objects:** Be aware that **Request-response calls between exclusive handlers of Virtual Objects may lead to deadlocks** (Cross deadlock: A $\to$ B and B $\to$ A; Cycle deadlock: A $\to$ B $\to$ C $\to$ A).
2.  **Avoid Sleeping in Exclusive Handlers:** **Do not sleep or wait for an awakeable** in an **exclusive handler** of a Virtual Object, as this will queue all other calls to that object key.
3.  **Avoid Idempotency Key Redundancy:** **Do not provide an idempotency key** for calls made *during the same handler execution*, as Restate handles deduplication automatically in that case.
4.  **Avoid Virtual Object Mutual Calls (Agents):** **Do not put mutually calling agents within the same Virtual Object keyed instance**, as this leads to deadlocks.

#### III. Deployment and Infrastructure

1.  **Avoid Dangerous Deployment Updates:** **Do not use PUT `/deployments/{deployment}`** (in-place update) unless absolutely necessary for failing invocations; it is a dangerous operation.
2.  **Avoid Incompatible Deployment Updates:** When updating a deployment, **do not change the service type**, and ensure the new deployment contains **at least all the previous services and handlers**, with the same supported protocol versions.
3.  **Avoid Non-Versioned Code Changes:** **Do not change the underlying service code** (e.g., update the container image) without registering a new immutable deployment version, as this causes **non-determinism errors** upon replay.
4.  **Avoid Unnecessary In-Place Updates:** Do not use **in-place updates** for deployment except for bug fixes in special situations; stick to immutable versions.
5.  **Avoid Dangerous Tunnel Access:** If the local remote proxy ports (8080 and 9080) are enabled via the tunnel client, be careful to **restrict access** to them.
6.  **Avoid Non-Snapshot Clusters:** **Running a distributed cluster without snapshots is not recommended for production use**.
7.  **Avoid Non-S3 Metadata Storage:** **Do not use S3-compatible stores other than S3 itself** (like MinIO) for cluster metadata storage.
8.  **Avoid Location String Change:** It is **strongly recommended to not change the node's location string** after its initial registration if the `log-server` role is enabled, as this may result in data loss or inconsistency.
9.  **Avoid Unauthorized Public Access:** **Do not allow unrestricted access** to publicly routable services.

#### IV. Cluster Management and Rollback

1.  **Avoid Using Deprecated Kill API:** **Do not use DELETE `/invocations/{invocation_id}`**; use `kill_invocation`/`cancel_invocation`/`purge_invocation` instead.
2.  **Avoid Killing Invocations Recklessly:** Be aware that **killing an invocation** does not guarantee consistency for virtual object instance state or in-flight invocations.
3.  **Avoid Corrupt Backups:** **Do not attempt to coordinate simultaneous backups across multiple nodes** due to the high risk of creating inconsistent data sets.
4.  **Avoid Deep Rollbacks:** **Do not roll back more than one minor version** behind the most recent version used with the data store.
5.  **Avoid Rollback after New Feature Use:** **Do not roll back** if you have used **new features exclusive to the newer version**.

#### V. Encryption

1.  **Avoid Assuming Full Encryption:** Be aware that **it is not possible to encrypt any journal entries** other than input/output parameters, `ctx.run` results, RPC parameters/return values, state values, Awakeables, and Durable Promise results.

The sources provide several operational recommendations, technical constraints, and warnings regarding deprecated usage for writing services using the Restate Go SDK.

Here are the itemized dos and don'ts derived from the provided material:

---

## Dos (Recommended Actions, Technical Requirements, and Positive Constraints)

### Prerequisites and Setup
*   **Do** ensure you are using Go version `>= 1.24.0`.
*   **Do** join the Restate online community for help, sharing feedback, and talking to the community.
*   **Do** check out the documentation to get quickly started.
*   **Do** follow Restate on Twitter for staying up to date.
*   **Do** create a GitHub issue for requesting a new feature or reporting a problem.
*   **Do** visit the GitHub organization for exploring other repositories.
*   **Do** join the Restate community and start contributing (whether through feature requests, bug reports, ideas & feedback, or Pull Requests).

### Concurrency and Asynchronous Operations
*   **Do** use `Context.Select` if you want to wait on multiple asynchronous results at once.
*   **Do** use the newer functions `WaitFirst`, `Wait`, or `WaitIter` when waiting for asynchronous results instead of the deprecated `Select`.
*   **Do** ensure the `Done()` method on an `AfterFuture` is always called, even after using `Context.Select`, as it can return a terminal error if the invocation was cancelled mid-sleep.

### Handler Definition and Reflection (`Reflect` API)
*   **Do** ensure methods intended as handlers are exported.
*   **Do** ensure handler methods are defined on the *exact type T* provided to the `.Reflect` function, and not on `*T`.
*   **Do** structure handler methods to have one of the accepted context types as the first parameter following the receiver (`WorkflowContext`, `WorkflowSharedContext`, `ObjectContext`, `ObjectSharedContext`, or `Context`).
*   **Do** ensure service handler methods have 2 or 3 input parameters (receiver, context, optionally input `I`).
*   **Do** ensure service handler methods return 0 to 2 output parameters (the acceptable signatures are `()`, `(O)`, `(error)`, or `(O, error)`).
*   **Do** ensure a workflow service definition has exactly one "Run" handler using `WorkflowContext`.

### Codec and Serialization
*   **Do** ensure that Codecs *must* marshal deterministically, such that a round trip of `[]byte` -> `any` -> `[]byte` leaves the bytes unchanged.
*   **Do** ensure that implementations of `RestateMarshaler` *must* be deterministic.
*   **Do** take care to ensure that only valid types are passed to a codec (e.g., `proto.Message` for `ProtoCodec`).

### Generated Code and Mocking
*   **Do** generate mockery mocks by running `mockery` in the root of the repo.
*   **Do** maintain the structure in `helpers.go` when regenerating mocks, ensuring certain mock structs/functions are redefined there and commented out in their respective files, which otherwise would be a build error.
*   **Do** embed `Unimplemented[Service]Server` by **value** (instead of pointer) to ensure forward compatible implementations and prevent nil pointer dereference when unimplemented methods are called.

### Runtime and Identity
*   **Do** use `restate.UUID` directly, instead of `restate.Rand().UUID()`.
*   **Do** use `.Bidirectional(false)` when serving over a channel that does not support full-duplex request and response (e.g., Cloudflare Workers) to prevent handlers from getting stuck.
*   **Do** restrict handler access if requests are accepted without validating request signatures (`r.keyIDs == nil`).

---

## Don'ts (Forbidden Actions, Warnings, and Deprecated Usage)

### Concurrency and Asynchronous Operations
*   **Don't** call `Response()` on `ResponseFuture` from inside a goroutine.
*   **Don't** call `Response()` on `AttachFuture` from inside a goroutine.
*   **Don't** call `Result()` on an awakeable (`AwakeableFuture`) from inside a goroutine.
*   **Don't** call `Result()` on `RunAsyncFuture` from inside a goroutine.
*   **Don't** call `Result()` on `DurablePromise` from inside a goroutine.
*   **Don't** use the `Selector` API when cancellation is possible, as it is deprecated and cancellation is not supported by this API.
*   **Don't** call `Done()` on `AfterFuture` from inside a goroutine.

### Deprecated Features
*   **Don't** use SDK versions `< 0.16`, as they are deprecated and cannot be registered anymore.
*   **Don't** use the `Select` function.
*   **Don't** use the type alias `Selectable`.
*   **Don't** use the type alias `Selector`.

### Handler Definition and Reflection
*   **Don't** define handler methods that are not exported.
*   **Don't** define handler methods with fewer than two input parameters.
*   **Don't** use a context parameter that doesn't match the service type when defining handlers (e.g., mixing `ObjectSharedContext` and `Context` in methods of the same reflected struct).
*   **Don't** define multiple methods using `WorkflowContext`; a workflow must have exactly one 'Run' method.
*   **Don't** define handler methods with more than one optional input parameter (after the context).
*   **Don't** return more than two parameters from a Restate handler.
*   **Don't** return two parameters from a handler where the second parameter is not an error.
*   **Don't** use streaming methods, as they are "not currently supported in Restate".
*   **Don't** set a handler type for services of type `SERVICE`.

### Service Configuration and Versioning
*   **Don't** set the `WorkflowRetention` option when creating a non-workflow service (e.g., Service or Object), as this will cause a panic.
*   **Don't** register multiple service definitions with the same name, as this is a programming error and will panic.

### Restate Server Version Constraints (Discovery Protocol V3/V4)
If registering a service against **Restate Server < 1.4** (Discovery Protocol Version V3 is required for these options):
*   **Don't** set `WithAbortTimeout` (for service or handler).
*   **Don't** set `WithEnableLazyState` (for service or handler).
*   **Don't** set `WithIdempotencyRetention` (for service or handler).
*   **Don't** set `WithInactivityTimeout` (for service or handler).
*   **Don't** set `WithIngressPrivate` (for service or handler).
*   **Don't** set `WithJournalRetention` (for service or handler).
*   **Don't** set `WithWorkflowRetention` (for service or handler).

If registering a service against **Restate Server < 1.5** (Discovery Protocol Version V4 is required for this option):
*   **Don't** set `WithInvocationRetryPolicy` (for service or handler).

# Per LLMS-FULL.TXT

Restate is designed around the principles of Durable Execution and consistency. The following comprehensive guidelines detail the essential do's and don'ts across key development categories, referencing specific SDK examples where available.

***

## Context

The Restate Context (`ctx`) is the central object that provides access to all durable capabilities and logging features within a handler.

### Do's (Recommendations)

1.  **Use Context for All Durable Actions:** Always use the Restate context (`ctx`) to interact with Restate features, such as state management, service calls, and timers. The SDK automatically stores these actions in the Restate journal to make them durable.
2.  **Use Context Logger for Logging:** For logging inside handlers, use the dedicated context logger (`ctx.console` in TypeScript, `ctx.Log()` in Go) to ensure clean, non-redundant logs and avoid duplicate statements during replays.
3.  **Generate Deterministic Values:** Use deterministic helpers provided by the SDK, like those for UUIDs (`restate.UUID(ctx)` in Go, `ctx.random().nextUUID()` in Java), to ensure the same result on retries and maintain determinism.

    ```go
    uuid := restate.UUID(ctx) //
    ```

### Don'ts (Avoidances)

1.  **Avoid Non-Deterministic Context Usage:** Do not branch execution flow based on non-deterministic information or pass non-deterministic values (like a raw random number or the current system date/time) as a parameter to a Context operation, as this violates determinism.
2.  **Avoid Using Deterministic IDs for Cryptography:** Do not use UUIDs generated by Restate's deterministic helpers in cryptographic contexts.

## Service Definition and Handlers

Services are the core unit of business logic, containing handlers (durable functions). They are classified as Basic Service, Virtual Object, or Workflow.

### Do's (Recommendations)

1.  **Define Services with Context:** Handlers must receive the appropriate Restate context type (e.g., `restate.Context` for Basic Services, `ObjectContext` for Virtual Objects, `WorkflowContext` for Workflows) as the first argument to enable durable interaction.
2.  **Use Exclusive Handlers for State Mutation:** For Virtual Objects and Workflows, use **Exclusive Handlers** (`ObjectContext`, `WorkflowContext`) for operations that read and write state. Only one exclusive handler runs at a time per key to prevent conflicts.
3.  **Use Shared Handlers for Concurrent Reads:** Use **Shared Handlers** (`ObjectSharedContext`, `WorkflowSharedContext`) for querying state, as they can run concurrently without blocking other operations on the object key.
4.  **Include the `Run` Handler in Workflows:** Every Workflow **must** include a `Run` handler, which acts as the main orchestration entry point and runs exactly once per workflow execution using the `WorkflowContext`.
5.  **Configure Timeouts for Long Operations:** If business logic or external calls (like LLM calls) might exceed the default 1-minute timeout, adjust the service's **inactivity timeout and abort timeout** settings.

    ```typescript
    options: {
        abortTimeout: { minutes: 15 },
        inactivityTimeout: { minutes: 15 },
        // ...
    }
    ```

6.  **Use AGENTS.md for AI Development:** When working with AI coding agents (like Cursor or Claude Code), download the relevant SDK's `AGENTS.md` file and put it in the agent's context directory (e.g., `.cursor/rules/`) to improve performance.

### Don'ts (Avoidances)

1.  **Do Not Catch Internal SDK Exceptions (Python):** **DO NOT** use bare `except:` or `except Exception:` in Python Restate handlers, as this catches internal SDK exceptions that should not be handled and can lead to unexpected behavior. Only catch specific exceptions like `TerminalError`.
2.  **Do Not Expose Internal Services:** Mark services as `ingressPrivate: true` via configuration to prevent them from receiving requests directly over HTTP or Kafka, allowing only internal service-to-service communication.
3.  **Do Not Rely on Non-JSON Serialization without Configuration:** While default serialization uses JSON (e.g., `encoding/json` in Go, built-in JSON in TypeScript), if using complex custom types, you must implement and configure custom serialization methods via `Serde` interfaces or options.

## Interservice Communication

Restate acts as a reliable RPC framework, proxying all communication between services and ensuring resilient delivery.

### Do's (Recommendations)

1.  **Use Context for Internal Calls:** Always invoke handlers via the Restate context (`ctx.serviceClient`, `ctx.objectClient`, etc.) if you have access to it. This attaches the call information to the parent invocation and ensures durability.
2.  **Choose Appropriate Communication Mode:** Select the mode based on needs:
    *   **Request-Response:** Call and wait for a result (`ctx.serviceCall`, etc.).
    *   **One-Way Message:** Fire-and-forget, guaranteeing delivery without waiting (`ctx.serviceSendClient`, etc.).
    *   **Delayed Message (Recommended for Scheduling):** Send a message to run after a specific delay.
3.  **Use Idempotency Keys When Necessary:** Use an idempotency key to prevent duplicate execution when calls originate from outside the current handler execution, or when multiple independent handlers might call the same service.

    ```go
    restate.ServiceSend(ctx, "MyService", "MyHandler").
        Send("Hi", restate.WithIdempotencyKey("my-idempotency-key")) //
    ```

4.  **Use Delayed Messages for Long Scheduling:** Use Delayed Messages instead of using `ctx.sleep` followed by a send, especially in Virtual Objects, as this allows the calling handler to complete immediately and prevents blocking the Virtual Object key.
5.  **Use Sagas for Rollback:** Implement compensating actions (Sagas) to ensure changes are rolled back or compensated for if a service call fails terminally or is explicitly canceled.

### Don'ts (Avoidances)

1.  **Avoid Deadlocks in Virtual Objects:** Be aware that **Request-response calls between exclusive handlers of Virtual Objects may lead to deadlocks** (Cross deadlock: A $\to$ B and B $\to$ A; Cycle deadlock: A $\to$ B $\to$ C $\to$ A). If deadlocked, you may need to use the CLI or UI to cancel the invocation.
2.  **Avoid Redundant Idempotency Keys:** Do not provide an idempotency key for calls made during the same handler execution, as Restate automatically handles deduplication in that scenario.

## Futures and Selectables

Futures/Promises represent the result of an asynchronous durable operation (like a call or a run block). Restate provides combinators to manage concurrency deterministically.

### Do's (Recommendations)

1.  **Use Concurrent Tasks for Performance:** Use concurrent tasks when you need to call multiple external services simultaneously, race operations for the first result, implement timeouts, or perform batch operations.
2.  **Use SDK Combinators for Concurrency:** Use SDK methods designed for durable concurrency, such as `restate.Wait` or `restate.WaitFirst` (Go), `DurableFuture.all` (Java/Kotlin), or `restate.gather` / `restate.select` (Python), to coordinate futures deterministically.
3.  **Implement Timeouts via Racing:** Implement timeouts by racing a service call future against a durable timer (`restate.After` / `ctx.sleep`) using combinators like `restate.WaitFirst` or `restate.select`.

    ```go
    // Go Example: Race a sleep against a service call
    sleepFuture := restate.After(ctx, 30*time.Second) //
    callFuture := restate.Service[string](ctx, "MyService", "MyHandler").RequestFuture("hi") //
    fut, err := restate.WaitFirst(ctx, sleepFuture, callFuture) //
    ```

### Don'ts (Avoidances)

1.  **Do Not Use Native Concurrency Primitives for Blocking Operations (Go):** **Do not try to combine blocking Restate operations using goroutines, channels, or select statements** outside of a `restate.Run` function. This causes non-determinism errors upon replay.
2.  **Do Not Wait for Results Indiscriminately:** When using `restate.WaitFirst` or `restate.select`, you must handle the result carefully, as Restate logs the *order of completion* to ensure deterministic replay.

## Run with Side Effects

The `ctx.run` feature allows executing non-deterministic or side-effecting operations outside of Restate’s core logic, while persisting the outcome for durability.

### Do's (Recommendations)

1.  **Wrap All Non-Deterministic Operations:** Use `ctx.run` (or equivalent SDK function) to safely wrap any non-deterministic operation, such as database calls, HTTP requests, or external service calls.
2.  **Ensure Resilience in Tools:** In AI agents, use `ctx.run` to make tool executions resilient, ensuring the tool's durable outcome is persisted for recovery.
3.  **Set Timeouts for Run Blocks:** Customize the retry policy or use the service/handler timeout configuration if a `ctx.run` block involves a long-running external process (e.g., up to 3 minutes for some LLM calls).

### Don'ts (Avoidances)

1.  **Do Not Use Context Inside `ctx.run`:** Inside a `ctx.run` block, **you cannot use the Restate context** (e.g., `ctx.get`, `ctx.sleep`, or nested `ctx.run`).
2.  **Do Not Rely on Unrecorded Side Effects:** Avoid branching execution flow based on the result of an HTTP request or other side effect that was not recorded using `ctx.run`, as this leads to non-determinism.

## Awakeables vs. Promise

These primitives are used for handlers that need to pause and wait for external processes (Callback/Task Token pattern).

### Do's (Recommendations)

1.  **Use Awakeables for External Coordination:** Use **Awakeables** for Services and Virtual Objects coordinating with **external systems** (human-in-the-loop, webhooks, async APIs). An Awakeable requires managing a unique ID for external resolution.
2.  **Use Durable Promises for Internal Workflow Signaling:** Use **Durable Promises** exclusively within **Workflows** for signaling between different workflow handlers. Promises use logical names instead of IDs and are scoped to the workflow execution lifetime.
3.  **Handle Rejections and Timeouts:** Always handle rejections from Promises/Awakeables to gracefully manage failures, and include timeouts for long-running waits.
4.  **Leverage FaaS Suspension:** Recognize that Restate suspends FaaS handlers while awaiting a Promise or Awakeable, which saves costs on serverless platforms.

### Don'ts (Avoidances)

1.  **Avoid Blocking Exclusive Handlers with Waits:** **Do not wait for an awakeable or sleep** in an **exclusive handler** in a Virtual Object, as this queues all other calls to that object key, severely impacting concurrency for that entity.
2.  **Avoid Using Durable Promises Outside Workflows:** Durable Promises are designed only for signaling within Workflows.

## State Management

State is a durable key-value store available only for Virtual Objects and Workflows.

### Do's (Recommendations)

1.  **Use State for Correctness and Consistency:** Store state that requires **tight integration with durable function logic** and strong consistency guarantees (e.g., transactional state machines, session state, AI agent context).
2.  **Use Exclusive Context for Read/Write:** Use `ObjectContext` (for Virtual Objects) or `WorkflowContext` (for Workflows `run` handlers) for handlers that need to read or write state.

    ```typescript
    // TypeScript Example (Exclusive Handler)
    const subscriptions = (await ctx.get("subscriptions")) ?? [];
    subscriptions.push(subscription);
    ctx.set("subscriptions", subscriptions); //
    ```

3.  **Use Shared Context for Read-Only Access:** Use `ObjectSharedContext` or `WorkflowSharedContext` for handlers that only read state, allowing them to run concurrently.
4.  **Explicitly Clear Long-Lived State:** Since Virtual Object state is retained indefinitely, use `ctx.clear()` or `ctx.clearAll()` when the state is no longer needed.
5.  **Choose State Loading Strategy:** Use **Eager state** (default) for small, frequently accessed state. Enable **Lazy state** for large state objects that are rarely accessed, as this reduces initial request size.

### Don'ts (Avoidances)

1.  **Do Not Mutate State in Shared Handlers:** Shared handlers can only read state and **cannot mutate it**.
2.  **Do Not Store Complex Query Data:** Use external databases when complex access patterns, full SQL, text search, or time-series analysis are required, or for core business data accessed by external services.
3.  **Do Not Assume Indefinite Workflow State:** Workflow state is only retained for the configured retention period (default 24 hours) after the `run` handler completes.

## Ingress Client

The ingress client library is used for invoking Restate handlers from applications that run outside the Restate environment and do not have access to the durable `Context`.

### Do's (Recommendations)

1.  **Use Client for External Invocation:** Use the specialized ingress clients (e.g., `restateingress.NewClient` in Go, `Client.connect` in Java/Kotlin) only in non-Restate services without access to the durable context.
2.  **Use Idempotency Keys on External Writes:** For external request-response or one-way calls, use idempotency keys via call options to prevent duplicate executions in the event of client retries.
3.  **Attach to Invocations (If Idempotent):** Use the ingress client's `Attach` feature to retrieve the final result of an ongoing invocation, but **only if an idempotency key was used**.

### Don'ts (Avoidances)

1.  **Do Not Use Ingress Clients for Internal Calls:** Always use the dedicated SDK context methods (`ctx.serviceCall`, etc.) for service-to-service communication within Restate handlers.
2.  **Do Not Expect Result Retrieval Without Idempotency Key:** If an invocation was initiated without an idempotency key, the external client can only wait for completion using `Attach`, but cannot retrieve the result.

## Communicating with Outside World

Restate mediates communication with external systems, often involving asynchronous waiting and security considerations.

### Do's (Recommendations)

1.  **Secure Public Endpoints:** If deploying services as publicly routable endpoints (e.g., serverless functions), it is crucial to **secure access** so that only the designated Restate environment can call them.
2.  **Use HTTPS for Public Endpoints:** If public endpoints are used, **HTTPS must be used** between Restate and your services.
3.  **Validate Request Identity:** Use Restate's native request identity feature/SDK methods to cryptographically verify that incoming requests originate from the correct Restate instance, especially when working with multiple Restate instances.
4.  **Use Delayed Messages for Scheduling:** Use delayed messages to schedule future work, as this avoids keeping old deployments around and prevents blocking Virtual Objects, making it superior to the `sleep + send` pattern or long sleeps in handlers.
5.  **Use Handlers as Durable Webhooks:** Any handler can function as a durable webhook processor. Leverage idempotency keys on the incoming webhook events to ensure **exactly-once processing** across sender retries.

### Don'ts (Avoidances)

1.  **Do Not Expose Dangerous Tunnel Ports:** If the tunnel client serves unauthenticated ingress and admin endpoints on local ports (8080 and 9080), **be careful to restrict access** to them.
2.  **Do Not Deploy Services Insecurely:** Unrestricted access to services is dangerous, as only the Restate Server should be able to proxy requests to them.

# Per Go SDK

This comprehensive list outlines the critical dos and don'ts for development using the Restate Go SDK, organized by the requested categories, drawing directly from the provided source material.

---

## Context

The context is the core object passed to handlers, providing access to all Restate durable operations. Different context types expose different capabilities (read-only vs. mutable state access).

| Do (Recommended Actions) | Don't (Avoid/Forbidden Actions) |
| :--- | :--- |
| **Do** pass context objects explicitly as the first non-receiver parameter to handler methods. | **Don't** call blocking futures methods (like `Response()` or `Result()`) from inside a standard Go routine; this is **not safe**. |
| **Do** use the appropriate context type for the handler's role: `Context` (for general Service), `ObjectSharedContext` (read-only Virtual Object), `ObjectContext` (mutable Virtual Object), `WorkflowSharedContext` (read-only Workflow), or `WorkflowContext` (mutable Workflow 'run'). | **Don't** mix different context types (e.g., `ObjectSharedContext` and `Context`) within the methods of a single reflected struct, as this causes a panic due to conflicting service definitions. |
| **Do** use `ctx.Log()` (which returns a `slog.Logger`) for logging within handlers. | **Don't** perform long-running blocking operations directly in the handler without yielding control (use futures or `Sleep`). |
| **Do** use `RunContext` (a limited context type) exclusively inside `restate.Run` closures. | **Don't** log messages when the invocation is replaying if the server is configured to `dropReplayLogs`. |
| **Do** use `ctx.Request()` to access metadata about the invocation, such as the unique ID, request headers, and attempt headers. | |

## Service Definition and Handlers

Defining services correctly ensures the Restate runtime can interpret and execute your logic durably.

| Do (Recommended Actions) | Don't (Avoid/Forbidden Actions) |
| :--- | :--- |
| **Do** ensure methods intended as handlers are exported (start with a capital letter). | **Don't** fail to export methods intended as handlers. |
| **Do** define handler methods on the **exact type T** provided to the `.Reflect` function, and not on `*T`. | **Don't** register multiple service definitions with the same name, as this is a programming error and will panic. |
| **Do** use `restate.Reflect` to convert a struct containing handler methods into a service definition. | **Don't** define streaming methods, as they are "not currently supported in Restate". |
| **Do** define handler signatures with 2 or 3 input parameters (receiver, context, optional input `I`). | **Don't** return more than two output parameters from a Restate handler. |
| **Do** ensure handlers return 0, 1, or 2 output parameters, with the supported forms being `()`, `(O)`, `(error)`, or `(O, error)`. | **Don't** return two parameters if the second one is not an `error`. |
| **Do** ensure a workflow service has exactly one "Run" handler using `WorkflowContext`. | **Don't** define multiple methods using `WorkflowContext` within a single workflow definition. |
| **Do** embed `Unimplemented[Service]Server` by **value** (not pointer) for forward compatibility when using generated code. | **Don't** panic when setting `WorkflowRetention` on a non-workflow service (Service or Object), which requires checking service type beforehand. |
| **Do** use `ServiceDefinition.ConfigureHandler(name, opts...)` to apply handler-specific configuration options like `WithEnableLazyState` or timeouts. | **Don't** set certain protocol V3/V4 options (like timeouts or retry policies) if targeting older Restate Servers (< 1.4 or < 1.5, respectively). |

## Interservice Communication

Communication involves calling other services or executing asynchronous durable operations.

| Do (Recommended Actions) | Don't (Avoid/Forbidden Actions) |
| :--- | :--- |
| **Do** use `restate.Service`, `restate.Object`, or `restate.Workflow` to obtain a `Client[I, O]` for calls originating inside a durable Restate handler. | **Don't** use the blocking `Request()` method when concurrent work is running; instead, use `RequestFuture()` to enable parallelism and coordination. |
| **Do** use `Client.Send()` for one-way (fire-and-forget) invocations. | **Don't** forget that `Send()` returns immediately with invocation metadata but does not retrieve the eventual response. |
| **Do** use `restate.WithDelay(duration)` with `Send()` calls if the message should be executed at a future time. | |
| **Do** pass `restate.WithIdempotencyKey(key)` when making requests or sends that require idempotent processing, such as retries from the caller. | |
| **Do** use `restate.CancelInvocation(ctx, invocationId)` to cancel an invocation identified by its ID. | |

## Futures and Selectables

Futures represent pending results of durable operations (calls, sleeps, runs, promises, awakeables).

| Do (Recommended Actions) | Don't (Avoid/Forbidden Actions) |
| :--- | :--- |
| **Do** use `WaitFirst`, `Wait`, or the low-level `WaitIter` to block and wait on multiple asynchronous results concurrently. | **Don't** use the deprecated `Select` function or the type aliases `Selector` and `Selectable`. |
| **Do** remember that blocking on a future using its `.Response()` or `.Result()` method must occur only on the main execution thread of the durable handler. | **Don't** call `Response()` on a `ResponseFuture` or `AttachFuture` from inside a separate goroutine. |
| **Do** call `.Done()` on an `AfterFuture` (`restate.After`) even if the future was selected by `WaitFirst`, as `.Done()` handles terminal errors resulting from mid-sleep cancellation. | **Don't** use the deprecated `Selector` API if cancellation is possible, as it does not support handling cancellation signals. |
| **Do** treat all futures (`ResponseFuture`, `AfterFuture`, `AwakeableFuture`, `RunAsyncFuture`, `DurablePromise`) as implementations of the `Future` interface (alias for `Selectable`) when using `Wait` or `WaitFirst`. | |

## Run with Side Effects

The `Run` primitive ensures that code execution that cannot be journaled and replayed deterministically is executed once and its results persisted.

| Do (Recommended Actions) | Don't (Avoid/Forbidden Actions) |
| :--- | :--- |
| **Do** place all **non-deterministic operations** inside a `restate.Run` closure (`fn`). | **Don't** execute non-deterministic operations directly in the main body of a durable handler, as this violates Restate's durability guarantees. |
| **Do** use `restate.Run` when you need the result of the side effect immediately and the operation should block the current thread. | **Don't** return a transient (non-terminal) error from the `Run` closure, as this triggers a retry of the whole invocation by Restate. |
| **Do** use `restate.RunAsync` if the side effect should run concurrently and participate in `Wait`/`WaitFirst` operations. | **Don't** call `Result()` on the returned `RunAsyncFuture` from a goroutine. |
| **Do** rely on the result being stored durably in the journal, ensuring subsequent replays yield the identical result. | |

## Awakeables vs. Promise

Both are mechanisms for blocking and waiting for an external signal or result, but they serve different communication boundaries.

| Do (Recommended Actions) | Don't (Avoid/Forbidden Actions) |
| :--- | :--- |
| **Do** use `restate.Awakeable` (`AwakeableFuture`) when waiting for an external resolution or rejection, typically by a different service via `ResolveAwakeable` or `RejectAwakeable`. | **Don't** call `Result()` on an `AwakeableFuture` in a goroutine. |
| **Do** use `restate.Promise` (`DurablePromise`) for asynchronous synchronization internal to a workflow instance, persisted across suspension and retries. | **Don't** use `DurablePromise` if the resolution must originate from a service outside the current workflow instance (use `Awakeable` instead). |
| **Do** obtain the unique `Id()` from an `AwakeableFuture` and pass it to the resolving service. | **Don't** attempt to Resolve or Reject a `DurablePromise` that has already been completed. |
| **Do** use `DurablePromise.Resolve(value)` or `DurablePromise.Reject(reason)` to complete a promise durably from within the workflow. | |
| **Do** use `DurablePromise.Peek()` to non-blockingly inspect the status of the promise. | |

## State Management

State management applies primarily to Virtual Objects and Workflows.

| Do (Recommended Actions) | Don't (Avoid/Forbidden Actions) |
| :--- | :--- |
| **Do** use `ObjectContext` (exclusive mode) when calling `Set(key, value)`, `Clear(key)`, or `ClearAll()`. | **Don't** call `Set`, `Clear`, or `ClearAll` inside a shared-mode handler (`ObjectSharedContext` or `WorkflowSharedContext`), as these are read-only contexts. |
| **Do** use `ObjectSharedContext` or `WorkflowSharedContext` when accessing state read-only via `Get(key)` or `Keys()`. | **Don't** use a non-pointer type `T` for `Get[T]` if you need to distinguish between a stored zero value and an absent key; pass a pointer type (e.g., `*string` as `T`) to check explicitly for absence. |
| **Do** use `restate.Key(ctx)` to retrieve the key associated with the current virtual object instance. | **Don't** perform state operations concurrently with other state-mutating operations in an exclusive handler. |
| **Do** handle potential cancellation errors that may occur when performing `Get` or `Keys` operations, especially if lazy state is enabled. | |

## Ingress Client

The ingress client is used for calling Restate from outside the durable Restate context (e.g., from a standard web application or external system).

| Do (Recommended Actions) | Don't (Avoid/Forbidden Actions) |
| :--- | :--- |
| **Do** use `ingress.NewClient(baseUri)` to create a client for external calls, optionally configuring it with authentication keys (`restate.WithAuthKey`). | **Don't** attempt to use `ingress` clients inside a Restate handler (use the internal `restate.Service` clients instead). |
| **Do** use `ingress.Service`, `ingress.Object`, or `ingress.Workflow` to get a `Requester[I, O]` if you might perform both synchronous requests (`Request`) and asynchronous sends (`Send`). | **Don't** use `ingress.ServiceSend`, `ingress.ObjectSend`, or `ingress.WorkflowSend` if you plan to retrieve the invocation output later, as these simplified clients do not carry the necessary output type parameter (`O`) needed for handling the final result. |
| **Do** use the modern attachment functions like `ingress.InvocationById`, `ingress.ServiceInvocationByIdempotencyKey`, or `ingress.WorkflowHandle` to attach to existing invocations. | **Don't** use the deprecated attachment functions such as `ingress.AttachInvocation`, `ingress.AttachService`, `ingress.AttachObject`, or `ingress.AttachWorkflow`. |
| **Do** include `restate.WithIdempotencyKey` when invoking requests or sends via the ingress client if you need to support retrieving the result later by key. | |

## Communicating with Outside World (External System/HTTP Server)

These guidelines cover server deployment and accessing external, non-durable logic.

| Do (Recommended Actions) | Don't (Avoid/Forbidden Actions) |
| :--- | :--- |
| **Do** wrap any interaction with the external world (e.g., accessing environment variables or making outbound HTTP calls) inside a `restate.Run` block to guarantee determinism. | **Don't** perform external, side-effecting operations outside a `restate.Run` block. |
| **Do** configure the server with `.Bidirectional(false)` if deploying to an environment that does not support full-duplex HTTP (like Cloudflare Workers) to prevent handlers from hanging. | **Don't** deploy to platforms without full-duplex support while using the default `BIDI_STREAM` protocol mode. |
| **Do** use `restate.WithHeaders` when making interservice calls via the SDK clients or ingress clients if custom headers are required. | **Don't** skip request signature validation (`WithIdentityV1`) if accepting external requests, especially if handler access is otherwise unrestricted. |
| **Do** use `WithPayloadCodec(codec)` to specify serialization/deserialization formats if default JSON is insufficient (e.g., using `WithBinary` for raw byte arrays). | |

---

These guidelines are designed to help build resilient applications using Restate's distributed durable async/await model. Following these practices helps align user code with the deterministic and fault-tolerant guarantees enforced by the Restate runtime.
