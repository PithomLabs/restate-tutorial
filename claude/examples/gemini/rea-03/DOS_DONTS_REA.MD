This comprehensive guide details the critical "Do's" and "Don'ts" for developing Restate applications using the principles and primitives introduced in the `github.com/pithomlabs/rea` framework, aligning them with core Restate concepts of durability and determinism.

---

## I. Determinism, Side Effects, and Logging

The Restate runtime relies on **Deterministic Execution** to guarantee replayability upon failure. Non-deterministic operations (Data Plane) must be executed once and stored in the journal, strictly separated from the orchestration logic (Control Plane).

|Category|Do (Required/Recommended)|Don't (Avoid/Forbidden)|Example/Primitive|
|:--|:--|:--|:--|
|**Data Plane Isolation**|**Do** wrap all non-deterministic side effects (external HTTP calls, database updates, file I/O) within `restate.Run`. The framework provides wrappers like `framework.RunDo[T]` or `framework.SafeRun[T]` to enforce context separation.|**Don't** perform any external, non-deterministic, or side-effecting operations directly in the main handler body.|**DO:** `framework.RunDo(ctx, func(rc restate.RunContext) (User, error) { return fetchUserFromDB(userID) })`. **DON'T:** `fetchUserFromDB()` outside `Run`.|
|**Context Misuse**|**Do** use `restate.RunContext` (aliased in `RunDo`/`SafeRun`) exclusively for the side effect logic. The framework helpers enforce this separation.|**Don't** use the outer Restate context (`ctx.Sleep`, `ctx.Client().Call()`, nested `ctx.Run`, `ctx.SetState()`) inside the `restate.Run` closure.|**DON'T:** `restate.Run(ctx, func(rc restate.RunContext) { ctx.Sleep(...) })`.|
|**Deterministic Values**|**Do** generate stable, deterministic UUIDs for IDs using `restate.UUID(ctx)`. The framework wraps this in `framework.DeterministicHelpers`.|**Don't** use UUIDs generated by Restate's deterministic helpers (`restate.UUID(ctx)`) for cryptographic purposes.|**DO:** `helpers := framework.NewDeterministicHelpers(ctx); uuid := helpers.UUID()`.|
|**Deterministic Time**|**Do** retrieve the current time using methods that capture it deterministically, such as `framework.NewTime(ctx).Now()`.|**Don't** use standard Go `time.Now()` directly in the durable orchestration logic.|**DO:** `now := framework.NewTime(ctx).Now()`.|
|**Logging**|**Do** use the Restate context logger (`ctx.Log()`, which returns an `*slog.Logger`) to ensure logs are not duplicated during replay.|**Don't** use standard Go logging packages (`fmt.Printf`, global `log/slog`) inside handlers.|**DO:** `ctx.Log().Info("Step completed")`.|

---

## II. State Management and Consistency

State is managed by Virtual Objects and Workflows. Exclusive contexts allow mutation, while shared contexts allow concurrent, read-only access.

|Category|Do (Required/Recommended)|Don't (Avoid/Forbidden)|Example/Primitive|
|:--|:--|:--|:--|
|**State Access**|**Do** use the type-safe state accessors provided by the framework to read state (`.Get()`).|**Don't** call state access functions (`restate.Get`/`Set`/`Clear`) from contexts that do not support them (e.g., a Basic Service context).|**DO (Read):** `state := framework.NewReadOnlyObjectState[Cart](ctx, "cart"); cart, err := state.Get()`.|
|**State Mutation**|**Do** ensure state mutation (`Set`, `Clear`, `ClearAll`) occurs only in **exclusive contexts** (`ObjectContext` or `WorkflowContext`). The framework guards against misuse.|**Don't** use `Set`, `Clear`, or `ClearAll` inside a shared context (`ObjectSharedContext` or `WorkflowSharedContext`).|**DO (Write):** `mutableState := framework.NewMutableObjectState[int](ctx, "counter"); mutableState.Set(newValue)`.|
|**Object Blocking**|**Do** use delayed messages (`Send` with `restate.WithDelay`) instead of `restate.Sleep` when managing time-based logic in Virtual Objects, allowing the handler to complete and prevent queuing.|**Don't** use `restate.Sleep(ctx, d)` or wait for an `Awakeable` inside a Virtual Object's exclusive handler (`ObjectContext`), as this blocks all subsequent calls to that object key, leading to queuing.|**DON'T:** `restate.Sleep(ctx, 5*time.Minute)` in `ObjectContext`.|
|**State Lifespan**|**Do** explicitly clear long-lived Virtual Object state when it is no longer required using `state.Clear()` or `framework.ClearAll(ctx)`.|**Don't** assume Workflow state lives indefinitely; it is retained only for the configured retention period (default 24 hours) after the `Run` handler completes.|**DO:** `framework.ClearAll(ctx)` when a session ends.|

---

## III. Communication (Internal RPC, External Ingress, and Signaling)

All communication between Restate services must go through the durable execution layer (Internal Clients). External communication uses the Ingress layer.

### III.A. Internal Communication (Within Durable Handlers)

|Category|Do (Required/Recommended)|Don't (Avoid/Forbidden)|Example/Primitive|
|:--|:--|:--|:--|
|**Client Type**|**Do** use the framework's internal clients (`framework.ServiceClient`, `ObjectClient`, `WorkflowClient`) when calling another service from within a durable handler.|**Don't** use `framework.NewIngressClient` or its derivatives inside a durable Restate handler. This bypasses the journal.|**DO:** `client := framework.ServiceClient[I, O]{ServiceName: "Svc"}`. **DON'T:** `ingress.NewClient(...)` inside `MyHandler`.|
|**Deadlock Avoidance**|**Do** use asynchronous calls (`RequestFuture`) and `restate.Wait` or refactor key usage to prevent deadlocks in Virtual Objects.|**Don't** implement complex request-response cycles (A $\to$ B $\to$ A) between exclusive Virtual Object handlers with the same key, as this leads to deadlocks.|**DON'T:** `DetectSelfReferencingCall(ctx, "MyObject", targetKey)` should return an error if `targetKey` is the current key.|
|**Async Signaling**|**Do** use `framework.WaitForExternalSignal[T](ctx)` (which calls `restate.Awakeable[T]`) for Services/Virtual Objects when coordinating with **external, non-Restate systems**.|**Don't** use `restate.Promise` (Durable Promise) outside of a Workflow.|**DO:** `awakeable := framework.WaitForExternalSignal[bool](ctx)`.|
|**Workflow Signaling**|**Do** use `framework.GetInternalSignal[T](ctx, name)` (which calls `restate.Promise[T]`) exclusively within **Workflows** for internal coordination between handlers.|**Don't** use `restate.Awakeable` for internal coordination within a Workflow instance; use Durable Promises instead.|**DO:** `promise := framework.GetInternalSignal[Result](ctx, "approval")`.|

### III.B. External Communication (Ingress Client)

|Category|Do (Required/Recommended)|Don't (Avoid/Forbidden)|Example/Primitive|
|:--|:--|:--|:--|
|**Client Initialization**|**Do** initialize the client using `framework.NewIngressClient(baseURL, authKey)` outside of any durable handler logic.|**Don't** try to use the durable context features when interacting with the Ingress Client, as you are operating outside the Restate runtime.|**DO:** `ingress := framework.NewIngressClient("http://restate:8080", "key")`.|
|**Idempotency Key Usage**|**Do** supply an `IdempotencyKey` via `framework.IngressCallOption` for all external request/send operations that need to be deduplicated.|**Don't** supply an idempotency key if the call is made during the execution of a durable handler, as it is redundant.|**DO:** `client.Send(..., IngressCallOption{IdempotencyKey: key})`.|
|**Identity Propagation**|**Do** ensure trusted identity (L2 security) is propagated using the `Headers` option in `framework.IngressCallOption` (e.g., `X-Authenticated-User-ID` header).|**Don't** rely on external services to trust an identity if it hasn't been verified by the Ingress (L1) and journaled (L2).|**DO:** `opts := IngressCallOption{Headers: map[string]string{"X-Authenticated-User-ID": userID}}`.|

---

## IV. Concurrency and Flow Control

Concurrency must be managed using Restate SDK primitives to maintain deterministic replay.

|Category|Do (Required/Recommended)|Don't (Avoid/Forbidden)|Example/Primitive|
|:--|:--|:--|:--|
|**Parallel Execution**|**Do** initiate multiple durable operations (RPCs, `RunAsync`, `After`) and use `restate.Wait` or `restate.WaitFirst` to collect results deterministically. The framework provides helpers like `framework.Gather` or `framework.FanOut`/`FanOutFail`.|**Don't** use native Go concurrency primitives (`go func()`, channels, standard `select` statements) when combining or waiting on blocking Restate operations (`Response()`, `Result()`, `Done()`) outside of a `restate.Run` block.|**DO:** Use `framework.FanOutFail(ctx, operations)` to run tasks concurrently and fail on the first error.|
|**Timeouts and Racing**|**Do** implement deterministic timeouts by racing a future against a durable timer created via `restate.After(ctx, duration)`. The framework provides a helper for this: `framework.RacePromiseWithTimeout`.|**Don't** rely on unreliable, non-durable timers (`time.After`, etc.) to control execution flow.|**DO:** `framework.RacePromiseWithTimeout(ctx, "approval_promise", 5*time.Minute)`.|
|**Workflow Timers**|**Do** use the `framework.WorkflowTimer` utilities for robust scheduling, especially `SleepUntil` for absolute time coordination.|**Don't** manually calculate `time.Time` offsets for `restate.Sleep` if the framework provides a dedicated utility.|**DO:** `framework.NewWorkflowTimer(ctx).Sleep(duration)`.|

---

## V. Error Handling and Sagas

Restate retries transient errors indefinitely by default. **Terminal Errors** stop retries, enabling compensation logic (Sagas).

|Category|Do (Required/Recommended)|Don't (Avoid/Forbidden)|Example/Primitive|
|:--|:--|:--|:--|
|**Stopping Retries**|**Do** throw `restate.TerminalError` (or use `framework.NewTerminalError`) when a non-recoverable business or structural failure occurs.|**Don't** allow transient errors (network hiccups, temporary database errors) to propagate as `TerminalError`, otherwise Restate cannot retry them.|**DO:** `return framework.NewTerminalError(errors.New("invalid input"))`.|
|**Saga Compensation**|**Do** implement compensating actions (Sagas) for multi-step transactions using Go's `defer` and a `TerminalError`.|**Don't** configure the retry policy to `KillOnMaxAttempts`, as this automatically fails the invocation without executing compensation logic.|**DO:** `defer cp.saga.CompensateIfNeeded(&err)` within the workflow handler.|
|**Compensation Order**|**Do** ensure compensation steps are registered _before_ the corresponding primary durable action is executed, especially for "one-shot" APIs. The `SafeStep` framework helper enforces this.|**Don't** register compensation _after_ the action has succeeded, risking lost compensation if the handler crashes immediately after the action but before registration.|**DO:** `step.WithCompensation(...).Execute(...)`.|
|**Idempotency of Sagas**|**Do** ensure all `framework.SagaCompensationFunc` implementations are idempotent, as they may be retried multiple times.|**Don't** write compensation logic that is sensitive to time or assumes it runs only once (e.g., incrementing a counter without checking preconditions).|**DO:** Compensating actions should use `framework.ValidateCompensationIdempotent` to document and enforce the contract.|

---

## VI. Security, Policy, and Infrastructure

Security measures must cover the external boundary (L1), identity propagation (L2), and internal service isolation (L3). The framework provides policy control over security checks.

|Category|Do (Required/Recommended)|Don't (Avoid/Forbidden)|Example/Primitive|
|:--|:--|:--|:--|
|**Framework Policy**|**Do** configure the global framework policy early using `framework.SetFrameworkPolicy()` to set strictness for all guardrails (e.g., use `PolicyStrict` in CI/Production).|**Don't** rely on `PolicyDisabled` or `PolicyWarn` in production, as this can lead to silent failures or inconsistencies.|**DO:** `framework.SetFrameworkPolicy(framework.PolicyStrict)`.|
|**Ingress Security (L1/L3)**|**Do** use `framework.SecurityMiddleware` (or related `SecureHandlerFunc`) to enforce cryptographic verification of the request signature (L3 security) and origin validation on publicly exposed service endpoints.|**Don't** allow unrestricted public access to Restate service endpoints; ensure only the trusted Restate Server can invoke them.|**DO:** `http.Handle("/restate", framework.SecurityMiddleware(validator)(restateHandler))`.|
|**Private Services**|**Do** mark internal utility services as private using the option `restate.WithIngressPrivate(true)` (if using Restate Server >= 1.4) to forbid external requests.|**Don't** expose internal utility services unnecessarily to the HTTP or Kafka ingress.|**DO:** Use `restate.NewService("Internal", restate.WithIngressPrivate(true))`.|
|**Idempotency Key Validation**|**Do** ensure idempotency keys are non-temporal and deterministic. The framework validates keys against suspicious patterns (like raw timestamps).|**Don't** generate idempotency keys using raw non-deterministic values like `time.Now()`.|**DON'T:** Use keys that contain patterns suggestive of timestamps.|

---

## VII. Primitives for External Coordination

The choice between Awakeables and Durable Promises depends on who resolves the wait.

|Primitive|Do (Use Case)|Don't (Avoidance)|Example/Go Primitive|
|:--|:--|:--|:--|
|**Awakeable**|**Do** use `restate.Awakeable[T]` (wrapped by `framework.WaitForExternalSignal`) when a Basic Service or Virtual Object must suspend and wait for an external system (webhook, payment gateway, human approval) to signal completion via the Restate ingress API.|**Don't** wait on an `Awakeable` in an **exclusive Virtual Object handler** (`ObjectContext`) without mitigating the blocking risk.|**DO (Wait):** `awakeable := framework.WaitForExternalSignal[Result](ctx); result, err := awakeable.Result()`. **DO (Resolve):** `framework.ResolveExternalSignal(ctx, id, value)`.|
|**Durable Promise**|**Do** use `restate.Promise[T]` (wrapped by `framework.GetInternalSignal`) exclusively within **Workflows** to coordinate signals between shared handlers and the main `Run` handler.|**Don't** use Durable Promises for coordination with systems _outside_ the Restate runtime.|**DO (Wait):** `promise := framework.GetInternalSignal[bool](ctx, "approval"); result, err := promise.Result()`.|

---
_**Analogy for Deterministic Execution:**_

Think of Durable Execution as following a **pre-recorded script for a play.**

- **Do (Control Plane):** The Restate handler code is the _Director's Instructions_. You **must** use built-in, repeatable stage directions like `restate.Sleep(duration)` or `ctx.Client().Call()` because the results of these actions are noted in the _Journal_ (the official script). When the actor (your service) crashes, Restate hands them a copy of the script and they restart exactly from the last completed scene.
- **Don't (Data Plane):** You **must not** improvise or use external inputs without noting them. If an action, like `ctx.Run(callExternalAPI)`, is required (improvisation), Restate logs the exact result in the script (e.g., "The result was '42'") the first time it runs. If the actor restarts, they simply read "The result was '42'" from the script instead of re-calling the external API, ensuring the play remains **deterministic** and exactly-once. Using `time.Now()` or a standard Go map inside your handler is like tearing up the script and ad-libbing the next line—it guarantees chaos when the play restarts.

---
## VIII. Services

This response addresses your query by detailing the purpose and usage of each Restate service type, outlining the required separation between the Control Plane and Data Plane, and providing comprehensive construction guidelines (Do's and Don'ts).

---

## 1. Service Typology: When to Use Which Service

The Restate SDK supports three primary service types—Basic Service, Virtual Object, and Workflow—each optimized for different concerns regarding state, concurrency, and process longevity.

|Service Type|Key Features & Constraints|When to Use (Rationale)|
|:--|:--|:--|
|**Basic Service** (Stateless Service)|Durable execution, unlimited parallel execution, no internal state between requests.|Use for **stateless business logic**, API integrations, task parallelization, ETL operations, or serving as a general orchestration point for Sagas and background jobs where concurrency is key.|
|**Virtual Object** (Stateful/Actor)|Isolated, persistent Key/Value (K/V) state per unique key. Guarantees **single-writer consistency** (exclusive handlers run serially per key).|Use to model **stateful entities** (like user accounts, shopping carts, chat sessions, or AI agents with memory). Essential for state machines where race conditions must be strictly prevented.|
|**Workflow**|Designed for **long-running, multi-step orchestration** with guaranteed **exactly-once execution** of the main `run` handler per workflow ID.|Use for processes requiring coordination across time, such as human approvals, user onboarding flows, or complex multi-step transactions using durable timers (`ctx.Sleep`) or internal signals (`Durable Promises`).|

### Sagas and Durable Coordination

- **Sagas:** The Saga pattern is implemented for **bulletproof transactions** that span multiple services. Sagas should be built within a **Workflow** or **Basic Service** to define compensating actions (rollbacks) that are executed if a non-transient failure occurs. In Go, this typically leverages the `defer` statement to register durable compensation calls.
- **Awakeables vs. Durable Promises:**
    - Use **Awakeables** for Services and Virtual Objects when coordinating with **external systems** (e.g., payment gateways, webhooks, human approval via API callback).
    - Use **Durable Promises** exclusively within **Workflows** for signaling and coordination between different handlers of the _same_ workflow instance (e.g., waiting for an internal approval signal).

---

## 2. Control Plane vs. Data Plane Separation

The robust nature of Restate applications stems from a strict architectural division required for **Durable Execution**. This separation ensures that code execution remains **deterministic** during replay after a crash.

|Feature|Control Plane (Orchestration/Durable Core)|Data Plane (Business Logic/Side Effect)|
|:--|:--|:--|
|**Analogy**|**Sequence of Steps** (like a Dockerfile/Workflow logic).|The actual external interaction or business logic computation.|
|**Purpose**|Defines the **flow, coordination, and state management** of the durable execution.|Handles **non-deterministic operations** and external side effects.|
|**Mechanism**|Primitives defined in the Restate SDK context, logged in the **journal**.|Must be wrapped in **`ctx.Run(fn)`** (Go SDK: `restate.Run(ctx, fn)`).|
|**Examples**|`ctx.Client().Call()`, `ctx.SetState()`, `ctx.Sleep()`, `ctx.Awakeable()`, `ctx.Promise()`.|External API calls, database writes/updates, sending emails, non-deterministic UUID generation, generating random numbers.|
|**Recovery Behavior**|**Replayed** on recovery to restore the exact control flow.|**Executed once** and its result is recorded in the journal. During replay, the function body is **skipped**, and the recorded result is returned.|

**Guidance on Construction:** The Control Plane is the durable backbone. Anything that defines _what_ happens next, _when_ it happens, or _where_ to store transient state belongs here. Conversely, any operation that interacts with the outside world (I/O, databases, external services) or produces a result that must be exactly-once delivered must be relegated to the Data Plane via `ctx.Run`.

---

## 3. General Do's and Don'ts for Service Construction

Adhering to these rules is critical for ensuring the resilience and determinism guaranteed by the Restate runtime.

### Construction Do's (Requirements and Best Practices)

|Category|Do|Rationale/Example|
|:--|:--|:--|
|**Determinism & I/O**|**Do** wrap all external APIs, database interactions, and other non-deterministic I/O operations inside `ctx.Run(fn)`.|Guarantees exactly-once side effects and prevents repeating expensive or state-changing operations during replay.|
|**Concurrency**|**Do** use Restate's durable combinators (`restate.Wait`, `restate.WaitFirst`, `RunAsync`) to run and coordinate asynchronous tasks in parallel.|Restate records the completion order of these durable operations, preserving deterministic replay logic.|
|**Timing & Delay**|**Do** use `ctx.Sleep(d)` (or `restate.After`) for durable timers and delays.|This timer survives worker crashes, suspends execution (saving FaaS costs), and resumes at the precise remaining time.|
|**State Management**|**Do** use `ctx.SetState()` and `ctx.GetState()` (Go SDK: `restate.Set/Get`) for managing persistent K/V state within Virtual Objects and Workflows.|Ensures state updates are consistent with the execution journal and survive failures.|
|**API Clients**|**Do** use **Internal Clients** (`ctx.Client()`, `restate.Service()`) for service-to-service calls inside handlers.|These calls are journaled by the Control Plane, ensuring durability, retries, and exactly-once semantics.|
|**Error Handling**|**Do** throw a `TerminalError` (or equivalent exception) for non-transient failures (e.g., invalid input, business logic failures).|Stops Restate from retrying indefinitely when recovery is impossible.|
|**Sagas**|**Do** ensure all compensating actions defined in a Saga are themselves **idempotent**.|Compensating calls are durable RPCs that are retried until they complete successfully, meaning they must withstand multiple executions.|

### Construction Don'ts (Actions to Avoid)

|Category|Don't|Risk/Rationale|
|:--|:--|:--|
|**Context Misuse (Critical)**|**Don't** use the parent Restate context (`ctx.Get`, `ctx.Client().Call`, `ctx.Sleep`, etc.) _inside_ a `ctx.Run(fn)` closure.|This violates the determinism guarantee, as the inner function is for side effects only (`RunContext`).|
|**Native Concurrency**|**Don't** use Go's native `goroutines`, `channels`, or `select` statements to manage or block on durable futures (like `fut.Response()`).|This introduces non-determinism, jeopardizing the integrity of the execution journal upon replay.|
|**Blocking Objects**|**Don't** use `ctx.Sleep()` or wait for an `Awakeable` in an **exclusive handler** (`ObjectContext`) of a Virtual Object.|This blocks all subsequent calls targeting the same object key, destroying concurrency for that entity.|
|**I/O and Time**|**Don't** call `time.Now()`, use `rand.Float64()`, or generate non-deterministic UUIDs outside of a `ctx.Run` block.|These values would differ during replay, leading to inconsistent state or unexpected control flow.|
|**Internal Calls**|**Don't** use the **Ingress Client** (the client used by external systems) inside a Restate handler.|This bypasses Restate's durable execution engine; the call won't be journaled and will repeat during replay.|
|**Concurrency Deadlocks**|**Don't** allow an exclusive Virtual Object handler to make a request-response call to another exclusive handler of the **same Virtual Object key**.|This creates a high risk of cross deadlocks or cycle deadlocks, halting the object's processing.|
|**Collection Iteration**|**Don't** iterate over standard Go maps (`map[K]V`) and execute Context operations (like `ctx.Call`) inside the loop body.|Standard maps have non-deterministic iteration order, which violates replay guarantees. Use deterministic collections if ordering matters.|

---

### Analogy: The Resilient Chef

Thinking about Control Plane (CP) versus Data Plane (DP) is like a resilient chef following a complex recipe:

1. **The Recipe (Control Plane):** This is the **fixed, sequential list of durable instructions** in the chef's log: "First, reliably reserve one chicken from the inventory (Call to InventoryService). Second, durable sleep for 30 minutes while the chicken marinates. Third, reliably charge the customer (Call to PaymentService). Finally, run the delivery step (Run/Side Effect)." If the kitchen catches fire, the chef simply looks at the last successfully completed step in the log (the CP journal) and resumes from the next line.
<<<<<<< HEAD
2. **The Ingredient Gathering and Cooking (Data Plane):** This is the **actual act of performing the side effects**, wrapped in a reliable utility. When the recipe says "run the delivery step," the chef sends a durable request to the external delivery app. This external action is non-deterministic (API call, database write, GPS check), but its result ("Delivery successful, tracking code 123") is logged by Restate _once_. If the chef restarts, the log simply tells them, "Delivery was successful, tracking code 123," and they move on, guaranteeing the delivery wasn't accidentally re-run (exactly-once delivery).
=======
2. **The Ingredient Gathering and Cooking (Data Plane):** This is the **actual act of performing the side effects**, wrapped in a reliable utility. When the recipe says "run the delivery step," the chef sends a durable request to the external delivery app. This external action is non-deterministic (API call, database write, GPS check), but its result ("Delivery successful, tracking code 123") is logged by Restate _once_. If the chef restarts, the log simply tells them, "Delivery was successful, tracking code 123," and they move on, guaranteeing the delivery wasn't accidentally re-run (exactly-once delivery).
>>>>>>> c8410c7 (♻️ Refactor to rea-04)
