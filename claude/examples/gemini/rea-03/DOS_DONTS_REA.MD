This comprehensive guide details the critical "Do's" and "Don'ts" for developing Restate applications using the principles and primitives introduced in the `github.com/pithomlabs/rea` framework, aligning them with core Restate concepts of durability and determinism.

---

## I. Determinism, Side Effects, and Logging

The Restate runtime relies on **Deterministic Execution** to guarantee replayability upon failure. Non-deterministic operations (Data Plane) must be executed once and stored in the journal, strictly separated from the orchestration logic (Control Plane).

|Category|Do (Required/Recommended)|Don't (Avoid/Forbidden)|Example/Primitive|
|:--|:--|:--|:--|
|**Data Plane Isolation**|**Do** wrap all non-deterministic side effects (external HTTP calls, database updates, file I/O) within `restate.Run`. The framework provides wrappers like `framework.RunDo[T]` or `framework.SafeRun[T]` to enforce context separation.|**Don't** perform any external, non-deterministic, or side-effecting operations directly in the main handler body.|**DO:** `framework.RunDo(ctx, func(rc restate.RunContext) (User, error) { return fetchUserFromDB(userID) })`. **DON'T:** `fetchUserFromDB()` outside `Run`.|
|**Context Misuse**|**Do** use `restate.RunContext` (aliased in `RunDo`/`SafeRun`) exclusively for the side effect logic. The framework helpers enforce this separation.|**Don't** use the outer Restate context (`ctx.Sleep`, `ctx.Client().Call()`, nested `ctx.Run`, `ctx.SetState()`) inside the `restate.Run` closure.|**DON'T:** `restate.Run(ctx, func(rc restate.RunContext) { ctx.Sleep(...) })`.|
|**Deterministic Values**|**Do** generate stable, deterministic UUIDs for IDs using `restate.UUID(ctx)`. The framework wraps this in `framework.DeterministicHelpers`.|**Don't** use UUIDs generated by Restate's deterministic helpers (`restate.UUID(ctx)`) for cryptographic purposes.|**DO:** `helpers := framework.NewDeterministicHelpers(ctx); uuid := helpers.UUID()`.|
|**Deterministic Time**|**Do** retrieve the current time using methods that capture it deterministically, such as `framework.NewTime(ctx).Now()`.|**Don't** use standard Go `time.Now()` directly in the durable orchestration logic.|**DO:** `now := framework.NewTime(ctx).Now()`.|
|**Logging**|**Do** use the Restate context logger (`ctx.Log()`, which returns an `*slog.Logger`) to ensure logs are not duplicated during replay.|**Don't** use standard Go logging packages (`fmt.Printf`, global `log/slog`) inside handlers.|**DO:** `ctx.Log().Info("Step completed")`.|

---

## II. State Management and Consistency

State is managed by Virtual Objects and Workflows. Exclusive contexts allow mutation, while shared contexts allow concurrent, read-only access.

|Category|Do (Required/Recommended)|Don't (Avoid/Forbidden)|Example/Primitive|
|:--|:--|:--|:--|
|**State Access**|**Do** use the type-safe state accessors provided by the framework to read state (`.Get()`).|**Don't** call state access functions (`restate.Get`/`Set`/`Clear`) from contexts that do not support them (e.g., a Basic Service context).|**DO (Read):** `state := framework.NewReadOnlyObjectState[Cart](ctx, "cart"); cart, err := state.Get()`.|
|**State Mutation**|**Do** ensure state mutation (`Set`, `Clear`, `ClearAll`) occurs only in **exclusive contexts** (`ObjectContext` or `WorkflowContext`). The framework guards against misuse.|**Don't** use `Set`, `Clear`, or `ClearAll` inside a shared context (`ObjectSharedContext` or `WorkflowSharedContext`).|**DO (Write):** `mutableState := framework.NewMutableObjectState[int](ctx, "counter"); mutableState.Set(newValue)`.|
|**Object Blocking**|**Do** use delayed messages (`Send` with `restate.WithDelay`) instead of `restate.Sleep` when managing time-based logic in Virtual Objects, allowing the handler to complete and prevent queuing.|**Don't** use `restate.Sleep(ctx, d)` or wait for an `Awakeable` inside a Virtual Object's exclusive handler (`ObjectContext`), as this blocks all subsequent calls to that object key, leading to queuing.|**DON'T:** `restate.Sleep(ctx, 5*time.Minute)` in `ObjectContext`.|
|**State Lifespan**|**Do** explicitly clear long-lived Virtual Object state when it is no longer required using `state.Clear()` or `framework.ClearAll(ctx)`.|**Don't** assume Workflow state lives indefinitely; it is retained only for the configured retention period (default 24 hours) after the `Run` handler completes.|**DO:** `framework.ClearAll(ctx)` when a session ends.|

---

## III. Communication (Internal RPC, External Ingress, and Signaling)

All communication between Restate services must go through the durable execution layer (Internal Clients). External communication uses the Ingress layer.

### III.A. Internal Communication (Within Durable Handlers)

|Category|Do (Required/Recommended)|Don't (Avoid/Forbidden)|Example/Primitive|
|:--|:--|:--|:--|
|**Client Type**|**Do** use the framework's internal clients (`framework.ServiceClient`, `ObjectClient`, `WorkflowClient`) when calling another service from within a durable handler.|**Don't** use `framework.NewIngressClient` or its derivatives inside a durable Restate handler. This bypasses the journal.|**DO:** `client := framework.ServiceClient[I, O]{ServiceName: "Svc"}`. **DON'T:** `ingress.NewClient(...)` inside `MyHandler`.|
|**Deadlock Avoidance**|**Do** use asynchronous calls (`RequestFuture`) and `restate.Wait` or refactor key usage to prevent deadlocks in Virtual Objects.|**Don't** implement complex request-response cycles (A $\to$ B $\to$ A) between exclusive Virtual Object handlers with the same key, as this leads to deadlocks.|**DON'T:** `DetectSelfReferencingCall(ctx, "MyObject", targetKey)` should return an error if `targetKey` is the current key.|
|**Async Signaling**|**Do** use `framework.WaitForExternalSignal[T](ctx)` (which calls `restate.Awakeable[T]`) for Services/Virtual Objects when coordinating with **external, non-Restate systems**.|**Don't** use `restate.Promise` (Durable Promise) outside of a Workflow.|**DO:** `awakeable := framework.WaitForExternalSignal[bool](ctx)`.|
|**Workflow Signaling**|**Do** use `framework.GetInternalSignal[T](ctx, name)` (which calls `restate.Promise[T]`) exclusively within **Workflows** for internal coordination between handlers.|**Don't** use `restate.Awakeable` for internal coordination within a Workflow instance; use Durable Promises instead.|**DO:** `promise := framework.GetInternalSignal[Result](ctx, "approval")`.|

### III.B. External Communication (Ingress Client)

|Category|Do (Required/Recommended)|Don't (Avoid/Forbidden)|Example/Primitive|
|:--|:--|:--|:--|
|**Client Initialization**|**Do** initialize the client using `framework.NewIngressClient(baseURL, authKey)` outside of any durable handler logic.|**Don't** try to use the durable context features when interacting with the Ingress Client, as you are operating outside the Restate runtime.|**DO:** `ingress := framework.NewIngressClient("http://restate:8080", "key")`.|
|**Idempotency Key Usage**|**Do** supply an `IdempotencyKey` via `framework.IngressCallOption` for all external request/send operations that need to be deduplicated.|**Don't** supply an idempotency key if the call is made during the execution of a durable handler, as it is redundant.|**DO:** `client.Send(..., IngressCallOption{IdempotencyKey: key})`.|
|**Identity Propagation**|**Do** ensure trusted identity (L2 security) is propagated using the `Headers` option in `framework.IngressCallOption` (e.g., `X-Authenticated-User-ID` header).|**Don't** rely on external services to trust an identity if it hasn't been verified by the Ingress (L1) and journaled (L2).|**DO:** `opts := IngressCallOption{Headers: map[string]string{"X-Authenticated-User-ID": userID}}`.|

---

## IV. Concurrency and Flow Control

Concurrency must be managed using Restate SDK primitives to maintain deterministic replay.

|Category|Do (Required/Recommended)|Don't (Avoid/Forbidden)|Example/Primitive|
|:--|:--|:--|:--|
|**Parallel Execution**|**Do** initiate multiple durable operations (RPCs, `RunAsync`, `After`) and use `restate.Wait` or `restate.WaitFirst` to collect results deterministically. The framework provides helpers like `framework.Gather` or `framework.FanOut`/`FanOutFail`.|**Don't** use native Go concurrency primitives (`go func()`, channels, standard `select` statements) when combining or waiting on blocking Restate operations (`Response()`, `Result()`, `Done()`) outside of a `restate.Run` block.|**DO:** Use `framework.FanOutFail(ctx, operations)` to run tasks concurrently and fail on the first error.|
|**Timeouts and Racing**|**Do** implement deterministic timeouts by racing a future against a durable timer created via `restate.After(ctx, duration)`. The framework provides a helper for this: `framework.RacePromiseWithTimeout`.|**Don't** rely on unreliable, non-durable timers (`time.After`, etc.) to control execution flow.|**DO:** `framework.RacePromiseWithTimeout(ctx, "approval_promise", 5*time.Minute)`.|
|**Workflow Timers**|**Do** use the `framework.WorkflowTimer` utilities for robust scheduling, especially `SleepUntil` for absolute time coordination.|**Don't** manually calculate `time.Time` offsets for `restate.Sleep` if the framework provides a dedicated utility.|**DO:** `framework.NewWorkflowTimer(ctx).Sleep(duration)`.|

---

## V. Error Handling and Sagas

Restate retries transient errors indefinitely by default. **Terminal Errors** stop retries, enabling compensation logic (Sagas).

|Category|Do (Required/Recommended)|Don't (Avoid/Forbidden)|Example/Primitive|
|:--|:--|:--|:--|
|**Stopping Retries**|**Do** throw `restate.TerminalError` (or use `framework.NewTerminalError`) when a non-recoverable business or structural failure occurs.|**Don't** allow transient errors (network hiccups, temporary database errors) to propagate as `TerminalError`, otherwise Restate cannot retry them.|**DO:** `return framework.NewTerminalError(errors.New("invalid input"))`.|
|**Saga Compensation**|**Do** implement compensating actions (Sagas) for multi-step transactions using Go's `defer` and a `TerminalError`.|**Don't** configure the retry policy to `KillOnMaxAttempts`, as this automatically fails the invocation without executing compensation logic.|**DO:** `defer cp.saga.CompensateIfNeeded(&err)` within the workflow handler.|
|**Compensation Order**|**Do** ensure compensation steps are registered _before_ the corresponding primary durable action is executed, especially for "one-shot" APIs. The `SafeStep` framework helper enforces this.|**Don't** register compensation _after_ the action has succeeded, risking lost compensation if the handler crashes immediately after the action but before registration.|**DO:** `step.WithCompensation(...).Execute(...)`.|
|**Idempotency of Sagas**|**Do** ensure all `framework.SagaCompensationFunc` implementations are idempotent, as they may be retried multiple times.|**Don't** write compensation logic that is sensitive to time or assumes it runs only once (e.g., incrementing a counter without checking preconditions).|**DO:** Compensating actions should use `framework.ValidateCompensationIdempotent` to document and enforce the contract.|

---

## VI. Security, Policy, and Infrastructure

Security measures must cover the external boundary (L1), identity propagation (L2), and internal service isolation (L3). The framework provides policy control over security checks.

|Category|Do (Required/Recommended)|Don't (Avoid/Forbidden)|Example/Primitive|
|:--|:--|:--|:--|
|**Framework Policy**|**Do** configure the global framework policy early using `framework.SetFrameworkPolicy()` to set strictness for all guardrails (e.g., use `PolicyStrict` in CI/Production).|**Don't** rely on `PolicyDisabled` or `PolicyWarn` in production, as this can lead to silent failures or inconsistencies.|**DO:** `framework.SetFrameworkPolicy(framework.PolicyStrict)`.|
|**Ingress Security (L1/L3)**|**Do** use `framework.SecurityMiddleware` (or related `SecureHandlerFunc`) to enforce cryptographic verification of the request signature (L3 security) and origin validation on publicly exposed service endpoints.|**Don't** allow unrestricted public access to Restate service endpoints; ensure only the trusted Restate Server can invoke them.|**DO:** `http.Handle("/restate", framework.SecurityMiddleware(validator)(restateHandler))`.|
|**Private Services**|**Do** mark internal utility services as private using the option `restate.WithIngressPrivate(true)` (if using Restate Server >= 1.4) to forbid external requests.|**Don't** expose internal utility services unnecessarily to the HTTP or Kafka ingress.|**DO:** Use `restate.NewService("Internal", restate.WithIngressPrivate(true))`.|
|**Idempotency Key Validation**|**Do** ensure idempotency keys are non-temporal and deterministic. The framework validates keys against suspicious patterns (like raw timestamps).|**Don't** generate idempotency keys using raw non-deterministic values like `time.Now()`.|**DON'T:** Use keys that contain patterns suggestive of timestamps.|

---

## VII. Primitives for External Coordination

The choice between Awakeables and Durable Promises depends on who resolves the wait.

|Primitive|Do (Use Case)|Don't (Avoidance)|Example/Go Primitive|
|:--|:--|:--|:--|
|**Awakeable**|**Do** use `restate.Awakeable[T]` (wrapped by `framework.WaitForExternalSignal`) when a Basic Service or Virtual Object must suspend and wait for an external system (webhook, payment gateway, human approval) to signal completion via the Restate ingress API.|**Don't** wait on an `Awakeable` in an **exclusive Virtual Object handler** (`ObjectContext`) without mitigating the blocking risk.|**DO (Wait):** `awakeable := framework.WaitForExternalSignal[Result](ctx); result, err := awakeable.Result()`. **DO (Resolve):** `framework.ResolveExternalSignal(ctx, id, value)`.|
|**Durable Promise**|**Do** use `restate.Promise[T]` (wrapped by `framework.GetInternalSignal`) exclusively within **Workflows** to coordinate signals between shared handlers and the main `Run` handler.|**Don't** use Durable Promises for coordination with systems _outside_ the Restate runtime.|**DO (Wait):** `promise := framework.GetInternalSignal[bool](ctx, "approval"); result, err := promise.Result()`.|

---

_**Analogy for Deterministic Execution:**_

Think of Durable Execution as following a **pre-recorded script for a play.**

- **Do (Control Plane):** The Restate handler code is the _Director's Instructions_. You **must** use built-in, repeatable stage directions like `restate.Sleep(duration)` or `ctx.Client().Call()` because the results of these actions are noted in the _Journal_ (the official script). When the actor (your service) crashes, Restate hands them a copy of the script and they restart exactly from the last completed scene.
- **Don't (Data Plane):** You **must not** improvise or use external inputs without noting them. If an action, like `ctx.Run(callExternalAPI)`, is required (improvisation), Restate logs the exact result in the script (e.g., "The result was '42'") the first time it runs. If the actor restarts, they simply read "The result was '42'" from the script instead of re-calling the external API, ensuring the play remains **deterministic** and exactly-once. Using `time.Now()` or a standard Go map inside your handler is like tearing up the script and ad-libbing the next lineâ€”it guarantees chaos when the play restarts.
